\chapter{Introdução} % upstream: 31aad54ac93dd33fb16df8470fa77450c17c1497 on Sep 9, 2016 
\label{introduction} %ideally we try to keep the line number in sync with the original file to make reference easier. This is (at this point) a pure translation not a version.
\state{NoContent}

\section{O que é o Haxe}
\label{introduction-what-is-haxe}

\todo{Could we have a big Haxe logo in the First Manual Page (Introduction) under the menu (a bit like a book cover ?) It looks a bit empty now and is a landing page for "Manual"}

Haxe consiste em uma linguagem de programação e um compilador, de alto nível e código aberto. Ele possibilita a compilação de programas, escritos em sintaxe similar a ECMAScript\footnote{http://www.ecma-international.org/publications/standards/Ecma-327.htm}, para múltiplas linguagens de destino(target\translatenote{nos referimos doravante a essas linguagens e plataformas simplesmente por \emph{targets}}). Empregando as abstrações adequadas é possível manter uma única base de código que compila para múltiplos targets.

Haxe é fortemente tipado, mas o sistema de tipagem pode ser subvertido quando preciso. Utilizando informações dos tipos, o sistema de tipagem do Haxe pode detectar erros em tempo de compilação que só seriam percebidos em tempo de execução no target. Mais além, as informações de tipos podem ser usadas pelos geradores de cada target para a criação de código otimizado e robusto.

Atualmente, existem nove targets suportados, que possibilitam diferentes ``casos de uso'':

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	Nome & Formato de saída & Usos principais \\ \hline
	Javascript & Sourcecode & Browser, Desktop, Mobile, Server \\
	Neko & Bytecode & Desktop, Server \\
	PHP & Sourcecode & Server \\
	Python & Sourcecode & Desktop, Server \\
	C++ & Sourcecode & Desktop, Mobile, Server \\
	Actionscript 3 & Sourcecode & Browser, Desktop, Mobile \\
	Flash & Bytecode & Browser, Desktop, Mobile \\ 
	Java & Sourcecode & Desktop, Server \\
	C\# & Sourcecode & Desktop, Mobile, Server \\ \hline
\end{tabular}
\end{center}

O restante da seção \ref{introduction} dá uma breve visão geral de com o que um programa em Haxe se parece e como o Haxe evoluiu desde de sua criação em 2005.

\Fullref{types} introduz as sete espécies de tipos em Haxe e discute como eles interagem uns com os outros. Isso continua em \Fullref{type-system}, onde funcionalidades como \emph{unificação}, \emph{parâmetros de tipo} e \emph{inferência de tipos} são explicadas.

\Fullref{class-field} é todo sobre as estruturas de classes do Haxe e, entre outros tópicos, lida com \emph{propriedades}, \emph{campos expandidos em linha}\translatenote{daqui em diante também referidos por \emph{inlined}} e \emph{funções genéricas}.

Em \Fullref{expression} vemos como fazer com que programas realmente façam algo através do uso de \emph{expressões}.

\Fullref{lf} descreve algumas das funcionalidades de Haxe em detalhe, tais como \emph{casamento de padrões},\translatenote{ou \emph{pattern matching}} \emph{interpolação de strings} e \emph{eliminação de código morto}. Isso conclui a referência para a linguagem Haxe.

Seguimos com o material de  referência para o compilador Haxe, que primeiro trata do básico em \Fullref{compiler-usage} antes de tocar nas funcionalidades mais avançadas em \Fullref{cr-features}. Finalmente nos aventuramos na estimulante terra das \emph{macros de Haxe} em \Fullref{macro} para ver como algumas tarefas comuns podem ser grandiosamente simplificadas.

No capítulo seguinte, \Fullref{std}, exploramos importantes tipos e conceitos da Biblioteca Padrão Haxe. Nós então aprendemos sobre o gerenciador de pacotes Haxelib em \Fullref{haxelib}.

Os tipos abstratos\translatenote{abstracts} em Haxe afastam muitas diferenças entre os targets, mas algumas vezes é importante interagir com diretamente com um target, o que é o assunto de \Fullref{target-details}.

\section{Sobre esse documento}
\label{introduction-about-this-document}

Esse documento é o manual oficial para o Haxe 3. Como tal, não é um tutorial para iniciantes e não ensina programação. Entretanto, os tópicos são grosseiramente concebidos para ser lidos em ordem e há referências para tópicos ``vistos anteriormente'' e a tópicos ``ainda por vir''. Em alguns casos, uma seção anterior faz uso de informação de uma seção adiante se isso simplifica a explicação. Essas referências são ligadas adequadamente e deveria, geralmente, não ser um problema a leitura adiantada sobre outros tópicos.

Usamos muito código fonte para manter uma conexão prática dos materiais teóricos. Esses exemplos de código são quase sempre programas completos que vem com uma função main que possa ser compilada ``como está''. Entretanto, algumas vezes unicamente as partes importantes são exibidas.
O código fonte aparece como este:

\begin{lstlisting}
Código haxe aqui
\end{lstlisting}
Ocasionalmente, nós demonstramos como o código de Haxe é gerado, para o que usualmente exibimos o target \target{Javascript}.

Mais além, definimos um conjunto de termos nesse documento. Predominantemente, isso é feito quando se introduz um novo tipo ou quando um termo é específico a Haxe. Nós não definimos todo novo aspecto que introduzimos, e.g. o que é uma classe, para evitar o inchamento do texto. As definições se parecem com:

\define{Nome definido}{define-definition}{Descrição da definição}

Em uns poucos lugares, esse documento tem caixas de \emph{trívia}. Essas incluem informações ``extra-oficiais'' tais como porque certas decisões foram tomadas durante o desenvolvimento do Haxe ou porque uma funcionalidade em particular foi mudada nas versões anteriores do Haxe. Essa informação é geralmente sem importância e pode ser pulada já que é unicamente dita para transmitir curiosidades:

\trivia{Assunto da Trivia}{Informações históricas sobre o desenvolvimento da linguagem}

\section{Autores e contribuições}
\label{introduction-authors-and-contributions}

A maior parte do conteúdo desse documento foi escrita por Simon Krajewski, enquanto trabalhando para a Haxe Foundation\translatenote{e traduzido para o português por Arthur Szász}. Gostaríamos de agradecer essas pessoas por suas contribuições\translatenote{também a Jonas Malaco: Compilação e edição em português}: 

\begin{itemize}
	\item Dan Korostelev: Conteúdo adicional e edição
	\item Caleb Harpre: Conteúdo adicional e edição
	\item Josefiene Pertosa: Edição
	\item Miha Lunar: Edição
	\item Nicolas Cannasse: Criador do Haxe
\end{itemize}

\subsection{Licença}
\label{introduction-license}

O Manual do Haxe pela \href{http://haxe.org/foundation}{Haxe Foundation} está licenciado sob a \href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.

Baseado nos trabalhos em \href{https://github.com/HaxeFoundation/HaxeManual}{https://github.com/HaxeFoundation/HaxeManual} e\\ \href{https://github.com/aszasz/Manual\_do\_Haxe}{https://github.com/aszasz/Manual\_do\_Haxe}.

\section{Hello World}
\label{introduction-hello-world}

O programa seguinte imprime ``Hello World'' depois de ser compilado e executado:

\haxe{assets/HelloWorld.hx}
Isso pode ser testado salvando o código acima em um arquivo chamado \ic{Main.hx} e invocando o compilador do Haxe assim: \ic{haxe -main Main --interp}. Ele então gera a seguinte saída: \ic{Main.hx:3: Hello world}. Há diversas coisas para aprender disso:
\todo{This generates the following output: too many 'this'. You may like a passive sentence: the following output will be generated...though this is to be avoided, generally}

\begin{itemize}
	\item Programas de Haxe são salvos em arquivos com extensão \ic{.hx}
	\item O compilador de haxe é uma ferramenta de linha de comando que pode ser chamada com parâmetros como \ic{-main} e \ic{--interp}
	\item Programas em haxe tem classes (\type{Main}, primeira letra maiúscula), que tem funções (\expr{main}, em minúsculas).
    \item O nome do arquivo contendo a principal classe de Haxe (main) é o mesmo nome da própria classe (nesse caso \type{Main.hx}).
\end{itemize}

\paragraph{Conteúdo relacionado}
\begin{itemize}
	\item \href{http://code.haxe.org/category/beginner/}{Beginner tutorials and examples} em Haxe Code Cookbook.
\end{itemize}

\section{Histórico}
\label{introduction-haxe-history}
\state{Reviewed}

O projeto Haxe começou em 22 de outubro de 2005 pelo desenvolvedor francês \emph{Nicolas Cannasse}, como um sucessor ao popular compilador de ActionScript2 \emph{MTASC} (Motion-Twin Action Script Compiler), de código aberto, e a sua própria linguagem \emph{MTypes}, que era uma experiência com a aplicação de inferência de tipos em uma linguagem orientada a objetos. A paixão de longa data de Nicolas pela concepção de linguagens de programação e o surgimento de novas oportunidades para juntar diferentes tecnologias como parte de seu trabalho desenvolvendo jogos na \emph{Motion-Twin} o levaram a criação de uma linguagem totalmente nova.

Escrita com X maiúsculo naquele tempo, a versão beta de haXe foi lançada em fevereiro de 2006, com os primeiros targets suportados sendo bytecode de AVM\footnote{Adobe Virtual Machine} e bytecode para \emph{Neko}\footnote{http://nekovm.org}, a maquina virtual do próprio Nicolas.

Nicolas Cannasse, quem permanece como líder do projeto do Haxe até esta data, continuou melhorando o Haxe com uma visão clara, levando à subsequente divulgação de Haxe 1.0 em maio de 2006. Essa primeira versão maior veio com suporte a geração de código para \target{Javascript} e já possuía algumas das funcionalidades que definem o Haxe hoje, como a inferência de tipos e a subtipagem estrutural.

Haxe 1 viu diversas versões menores ao longo de dois anos, ganhando \target{Flash AVM2} como target junto com a ferramenta {haxelib} em agosto de 2006 e o target\target{Actionscript 3} em março de 2007. Durante esses meses, houve forte focalização na melhoria da estabilidade, que resultaram em diversas versões resolvendo pequenos bugs.

Haxe 2.0 foi divulgado em julho de 2008, incluindo o target \target{PHP}, cortesia de \emph{Franco Ponticelli}. Um esforço similar de \emph{Hugh Sanderson} levou a adição do target \target{C++} em julho de 2009, junto com a versão 2.04

Assim como com o Haxe 1, o que seguiu foram diversos meses de atualizações de estabilidade. Em janeiro de 2011 a versão 2.07 foi divulgada com o suporte a \emph{macros}. Por volta dessa época, \emph{Bruno Garcia} se juntou a equipe como mantenedor do target \target{Javascript}, que viu vastas melhorias nos lançamentos seguintes: 2.08 e 2.09.

Depois da versão 2.09, \emph{Simon Krajewski} se juntou ao time e o trabalho em direção ao Haxe 3 começou. Além disso, os targets \target{C\#} e \target{Java} de \emph{Cauê Waneck} acharam seus caminhos para dentro dos builds do Haxe. Decidiu-se, então, fazer uma versão final do Haxe 2, que aconteceu em julho de 2012, com a divulgação do Haxe 2.10.

No final de 2012, a chave para o Haxe 3 foi virada e a equipe do Compilador Haxe, agora amparada pela recém-fundada \emph{Haxe Foundation}\footnote{http://haxe-foundation.org}, se focou nesta próxima grande versão. O Haxe 3 foi subsequentemente lançado em maio de 2013.

