% commit do Manual original: e16ca549e9966556e8ffbe3fcb0c459cad17ddaf

\chapter{Introdução}

\section{O que é o Haxe}

Haxe é uma linguagem de programação de alto nível e um compilador que permite a compilação de programas escritos em sintaxe similar ECMAScript (JavaScript) que sejam transformados em programas em outras linguagens, atualmente 9, ou como nos referimos doravante targets. O código do compilador de Haxe é aberto


O restante do capítulo dá uma breve descrição de com o que um programa em Haxe se parece e como o Haxe evoluiu desde de 2005.

Tipos (ver capítulo 2) introduz as sete espécies de tipos em Haxe e discute como eles interagem uns com os outros. A discussão continua em Type System (ver capítulo 3), onde funcionalidades como unificação, parâmetros de tipo e inferência de tipo são explicadas.

Campos de classe (ver capítulo 4) é totalmente sobre as estruturas de classes do Haxe e, entre outros tópicos, lida com propriedades, campos alinhados e funções genéricas.

Em Expressões (ver capítulo 5) vemos como se faz com que os programas realmente façam algo usando expressões.

Funcionalidades da Linguagem (ver capítulo 6) descreve algumas das funcionalidades do Haxe em detalhe, tais como localização de padrões, interpolação de strings e eliminação de código morto. Isso conclui a referência para linguagem Haxe

Continuamos com a referência para o compilador de Haxe, que primeiro trata do básico em Uso do Compilador (ver capítulo 7) antes de prosseguir para a funcionalidades avançadas em Funcionalidades do Compilador (ver capitulo 8). Finalmente nos aventuramos no mundo estimulante das macros de Haxe em Macros (ver capítulo 9) para ver como algumas tarefas comuns podem ser intensamente simplificadas.

No capítulo seguinte, Biblioteca Padrão (ver capítulo 10), exploramos tipos importantes e conceitos da Biblioteca Padrão do Haxe. Nós então aprendemos sobre o gerenciador de pacotes Haxelib em Haxelib (ver capítulo 11).

Os abstratos de Haxe afastam muitas diferenças entre os targets, mas algumas vezes é importante interagir com um target diretamente, o que é o assunto de Detalhamento dos Targets (ver capítulo 12).

\section{Sobre esse documento}

Esse documento é o manual oficial para o Haxe 3. Como tal, não é um tutorial para iniciantes e não ensina programação. Entretanto os tópicos são grosseiramente concebidos para ser lidos em ordem e há referências para tópicos "vistos anteriormente" e a tópicos "ainda por vir". Em alguns casos, uma seção anterior faz usa de informação de uma seção adiante se isso simplifica a explicação. Essas referências são referenciadas adequadamente e não deve ser geralmente um problema a leitura adiantada de outros tópicos.
É o manual oficial, não um guia para aprendizado.

Utilizamos muito código fonte  para manter uma conexão prática com o material teórico. Esses  exemplos de código são frequentemente programos completos que vem com uma função main que possa ser compilada "como está". Entretanto, algumas vezes unicamente as partes importantes são exibidas. Código fonte aparece assim:

Código haxe aqui

Ocasionalmente, nós demonstramos como o código é gerado,par o qual normalmente mostramos o target Javascript.

Além do mais, definimos um conjunto de termos nesse documento. Predominantemente, isso é feito quando se introduz um novo tipo ou quando um termo é específico ao Haxe. Nõa definimos todo novo aspecto que introduzimos, e.g., oque é uma classe, para evitar inchar o texto.

\definition{Definição}{Descrição}

Em alguns lugares, esse documento tem caixas de trívia. Essas incluem informações sem importância como registo, tais como porque certas decisões foram tomadas durante o desenvolvimento do Haxe ou porque uma funcionalidade em particular foi mudada nas versões anteriores do Haxe. Essas informações são geralmente pouco importantes e podem ser puladas uma vez que pretenderm trazer apenas trivia:

\trivia{Assunto da Trivia}{Informações históricas sobre o desenvolvimento da linguagem}

\section{Autores e contribuições}

A maior parte do conteúdo desse documento foi escrita por Simon Krajewski enquanto trabalhando para a Haxe Foundation. Gostaríamos de agradecer essas pessoas por suas conntribuições:

Dan Korostelev: Conteúdo adicional e edição

Caleb Harpre: Conteúdo adicional e edição

Josefiene Pertosa: Edição

Miha Lunar: Edição

Nicolas Cannasse: Criador do Haxe


\section{Hello World}

O programa seguinte imprime "Hello World" depois de ser compilado e executado:

class HelloWorld {
     static public function main():Void {
          trace("Hello World");
     }
}

Isso pode ser testado salvando o código acima em um arquivo chamado HelloWorld.hx e chamando o compilador do Haxe assim: haxe -main HelloWorld --interp. Ele então gera a seguinte saída: HelloWorld.hx:3 Hello world . Há diverssas coisas para aprender disso:

- Programas de Haxe são salvos em arquivos com uma extensão .hx

- O compilador de haxe é uma ferramenta de linha de comando que pode ser chamada com parâmetros como -main e --interp

- Programas em haxe tem classes (HelloWorld, com maíuscula), que tem funções (main, com minúscula).

\section{History}
O projeto foi iniciado em 22 de outubro de 2005 pelo desenvolvedor francês Nicolas Canasse, como um sucessor ao popular compilador de ActionScript2, de código aberto, MTASC (Motion-Twin Action Script Compiler) e a sua própria linguagem MTypes, uma experiência com a aplicação de inferência de tipos a uma linguagem orientada a objetos. A paixão de longa data de Nicolas pela estruturação de linguagens de programação e as novas oportunidades de juntar diferentes tecnologias como parte de seu trabalho como desenvolvedor de jogos na Motion-Twin o levaram a criação de uma linguagem totalmente nova.

Escrita com X maiúsculo então, a versão beta de haXe foi lançada em fevereiro de 2006, com os primeiros targets sendo bytecode para AVM (Adobe Virtual Machine) e bytecode para Neko, uma Virtual Machine também criada por Nicolas.

Nicolas Canasse, quem lidera o projeto do Haxe até o momento, continuou melhorando o Haxe com uma visão clara, levando a divulgação de Haxe 1.0 em maio de 2006. Essa primeira versão veio com suporte a geração de código a Javascript e já possui algumas das funcionalidades que definem o Haxe hoje, como a inferência de tipos e a subtipagem estrutural.

Haxe 1 sofreu algumas modificações menores ao longo de dois anos, ganhando Flash AVM2 como target e a ferramenta haxelin em agosto de 2006 e o target Actionscript3 em março de 2007. Durante esses meses, o foco esteve em melhorara estabilidade, do que resultou a resolução de diversos pequenos bugs.

Haxe 2.0 foi divulgado em julho de 2008, incluindo o target PHP, cortesia de Franco Ponticelli. Um esforço similar de Hugh Sanderson levou a adição do target C++ em julho de 2009 com a versão 2.04

Assim como Haxe 1, o que se sseguiu foram diversas versões com mais estabilidade. Em Janeiro de 2011 saiu a versão 2.07 com suporte a macros. Nesse período, Bruno Garcia se juntou a equipe como mantenedor do target Javascript, que recebeu inúmeras melhorias nos lançamentos seguintes: 2.08 e 2.09.

Depois da versão 2.09, Simon Krajewsku se juntou ao time e o trabalho em direção ao Haxe 3 começou. Além disso, os targets C# e Java de Cauê Waneck entraram nas compilações da linguagem. Decidiu-se então fazer uma versão final do Haxe 2, que aconteceu em julho de 2012, a versão 2.10.

No final de 2012, o botão virou para o Haxe 3 e a equipe do Compilador Haxe, agora apoiada pela recém fundada Haxe Foundation, se focou nessa nova versão. Haxe 3 foi lançado subsequentemente em Maio de 2013.

Parte I - Guia da Linguagem

\chapter{Tipos(Types)}

o Compilador Haxe emprega um detalhado sistema de tipos que ajuda a detectar erros relacionados a tipagem em um programa no momento da compilação. Um erro relacionado a tipagem é uma operação inválida para um dado tipo, como a divisão por um string, o acesso ao campo de um Integer ou a chamada a uma função com menos (ou mais) argumentos que o necessário).

Em algumas linguagens essa segurança adicional vem com um preço porque os programadores são obrigados a indicar explicitamente os tipos em suas construções sintáticas:

var myButton:MySpecialButton =
    new MySpecialButton(); // As3
MySpecialButton* myButton =
    new MySpecialButton(); // C++

As indicações explicitas de tipos não são requeridas em Haxe, porque o compilador pode inferir o tipo:

var myButton = new MySpecialButton(); // Haxe

A inferência de tipos será explorada em detalhes depois (Seção 3.6 Type Inference). Por hora basta saber que a variável myButton no código acima é sabidamente uma instância da classe MySpecialButton.

O sistema de tipos do Haxe reconhece sete grupos de tipos:

Instância de classe: um objeto de uma dada classe ou interface

Instância de enum: um valor de uma enumeração do Haxe

Estrutura: uma estrutura anônima, i.e., uma coleção de campos com nomes

Função: um tipo composto de vários argumentos e um retorno

Dinâmico: um tipo coringa que é compátivel com qualquer tipo

Abstrato: um tipo no momento de compilação que é representado por um tipo diferente em momento de execução

Monomorfo: um tipo desconhecido que pode posteriormente se tornar um tipo diferente

Cada um desses grupos de tipos serão descritos, bem como as relações entre eles nos próximos capítulos.

(N do T: a palavra type pode aparecer nessa tradução, ao invés de tipo, se facilitar a compreensão. Nesse caso texto dirá algo como "o type convertido")

Definição: Tipo composto
Um tipo composto é um tipo que tem subtipos. Isso inclui qualquer tipo com parâmetros de tipo(3.2) e o tipo função (2.6)

\section{Types Básicos}

Os tipos básicos são Bool, Float e Int

Os tipos básicos não são classes em Haxe. Eles são implementados como tipos abstratos e estão ligados ao manuseio de operadores internos do compilador, como descrito nas seções seguintes.

\subsection{Tipos numéricos}

Definition{Tipo:Float}{Representa um número de ponto flutuante de 64-bits de dupla precisão (IEEE)

Definition{Tipo:Int}{Representa um número inteiro}

Todo Int pode ser usado aonde se espera um FLoat (isso é, Int é atribuível ou é unificável com Float), o contrário não é verdade: atribuir um Float a um Int pode exigir perda de precisão e não é implicitamente permitido.

\subsection{Overflow - Estouro de Capacidade}

Por razões de desempenho, o Compliador de Haxe não controla o comportamento do estouro de capacidade. A responsabilidade de verificar o estouro de capacidade cai sobre a plataforma do target. Aqui se vem algumas observações especificas de comportamento de estouro:

C++, Java, Neko e Flash: inteiros, com sinal, de 32 bits com práticas usuaisPHP, JS, Flash 8: Não tem o tipo nativo Int, a perda de precisão ocorrerá se eles atingirem seus limites de float (2^52 2 ⁵²)

Alternativamente, as classes haxe.Int32 e haxe.Int64 podem ser utilizadas para assegurar o correto comportamento de estouro indiferentemente da plataforma ao custo adicional das computações dependentes da plataforma.

\subsection{Operações Numéricas}

\subsection
\definition{Tipo:Bool(Booleano)}{Representa um valor que pode ser true ou false (verdadeiro ou falso)}

Valores do tipo Bool são uma ocorrência comum em condicionais como if(ver 5.16 if) e while (while 5.14). 

Os seguintes operadores aceitam e retornam valores Bool:

&& (and)
|| (or)
!  (not)

O Haxe garante que as expressões booleanas são avaliadas da esquerda para a direita e apenas até onde for necessário durante o momento da execução. Por exemplo, uma expressão como A && B  avaliará primeiro A, e só avaliará B se A for verdadeira. Da mesma forma, expressões como A||B não avaliarão B se A for verdadeira. Isso é importante em casos como:

Acessar object.field se object for nill levaria a um erro de execução, mas a verificação object!=null previne isso.

\section {Void (Vazio)}

\definition{Tipo Void}{Void indica a ausência de um tipo. É usado para expressar que algo (normalmente uma função) não tem um valor}

Void é um caso especial no sitema de tipos porque não é em si um tipo. Ele é usado para expressar a ausência de um tipo. Já vimos Void no exemplo inicial "Hello World":

O tipo função será explorado em detalhe na seção Function Type (2.6) mas uma rápida visão é útil aqui: O tipo da função main no exemplo atnerior é Void-->Void, que se lê: "não tem argumentos e nem valor de retorno (retorna 'nada')". o Haxe não permite variáveis do tipo Void e reclama se uma tentativa de declarar é feita:

\section{Nulabilidade}
 \definition{nullable}{Um tipo em Haxe é considerável nulável se null é um valor válido para ele}

((
N. do T: 
Uma tentativa de explicar o termo:
inexistenciabilidade
um tipo é nullable se pode assumir o valor null: não existe, pode assumir o valor "inexistente"}
))

É comum linguagens de programação terem uma única definição clara de nulabilidade. No entanto, o Haxe tem que se comprometer em relação a esse assunto em função da natureza das linguagens dos targets:
Enquanto algumas delas permitem e, de fato, utilizam null como valor padrão  para todas as coisas, outras linguagens não chegam a permitir o valor null 
para certos tipos. Isso gera a necessidade de criar a distinção entre dois tipos de targets:

\definition{Target estático}{Targets estáticos empregam sistemas de tipificação onde null é um valor inválido para os tipos básicos. Esse é o caso de Flash, C++, Java e C#}

\definition{Target dinâmico}{Targets dinâmicos são mais lenientes em relação aos seus tipos e permitem o valor null para tipos básicos. Isso se aplica a Javascript, PHP, Neko e Flash 6-8}

Não há nada para se preocupar quando se trabalha com null em targets dinâmicos; no entanto targets estáticos demandam alguma atenção. Inicialment, tipos básicos são inicializados com seus valores default

\definition{Valores Default}{Tipos násicos tem os seguintes valores em targets estáticos

Int: 0

Float: NaN (not a number) em Flash, 0.0 nos demais

Bool: false
}

Como consequência o Compilador de Haxe não permite que se atribua null a um tipo básico em targets estáticos. De forma a conseguir isso, o tipo básico tem que ser envelopado como Null<T>:

Similarmente, tipos básicos não podem ser comparados a null, a não ser que sejam envelopados:

Essa restrição se estende a todas as situações onde acontece a unificação (ver unificação 3.5).

\definition{Type:Null<T>}{Em targets estáticos os tipos Null<Int>, Null<Float> e Null<Bool> podem ser utilizados para permitir null como um valor. Em targets dinâmicos esse envelopamento não tem nenhum efeito. Null<T> também pode ser usados com outros tipos de forma a documentar que null é um valor permitido.}

Se um valor null é "escondido" em Null<T> ou Dynamic e atribuído a um tipo básico, o valor default da plataforma target é utilizado.

\subsection{Argumentos Opcionais e Nulabilidade}

Argumentos opcionais também precisam ser levados em conta quando se considera a nulabilidade.

Em especial, deva haver uma disitinção entre argumentos opcionais nativos que não são nuláveis e argumentos opcionais específicos do Haxe que podem ser nuláveis. A distinção pode ser feita utilizando o argumento opcional ponto-de-interrogação:

\trivia{Argumentos x Parametros}{Em outras linguagens de programação, argumentos e parâmetros são termos intercambiáveis. Em Haxe, argumento é usado quando nos referimos a métodos e parametro quando nos referimos a parâmetros de tipos (ver Type Parameters)}

\section{Instância de Classe}
Similar a muita linguagens orientadas a objeto, classes são a estrutura de dados primárias para a maioria dos programas em Haxe. Cada classe de Haxe tem um nome explícito, um caminho específico e zero ou mais campos de classe. Aqui nos focaremos na estrutura geral de classes e em suas relações e deixaremos os detalhes dos campos de classe para o Capítulo 4.

O seguinte exemplo de código serve de base para o resto dessa seção:

Semanticamente, essa classe representa um ponto discreto no espaço bidimensional, mas isso não é importante aqui. Vamos nos concentrar primeiro em descrever a estrutura:

- A palavra-chave class informa que estamos declarando uma classe

- Point é o nome da classe e poderia ser qualquer nome conforme as regras de identificadores de tipo (referência a pag. 68)

- Chaves são os campos de classe,

- que consistem em dois campos de variáveis x e y, do tipo Int,

- seguidos de um campo de função especial chamada new, que é o constructor da classe,

- bem como uma função normal toString

Há um tipo especial em Haxe que é compatível com todas as classes:

\definition{Type:Class<T>}{Esse tipo é compatível com todos os tipos de classe, o que siginifica que todas as classes (não suas instâncias) podem ser atribuídas a ele. Durante a compilação, Class<T> pe o tipo base comum de todos os tipos de classes. Entretanto essa relação não é refletida no código gerado.

Esse tipo é útil quando uma API exige que um valor seja uma classe, mas nenhuma específica. Isso se aplica a diversos métodos da API Haxe Reflection (10.6).

\subsection{Class constructor}

Instâncias de classes são criadas na chamada do class constructor - um processo comumente referido por instanciação. Outro nome para instâncias de classes é objeto. Apesar disso, preferimos o termo instância de classe, por enfatizar a analogia entre classes/instâncias de classes e enums/instâncias de enums (ver 2.4).

var p = new Point (-1, 65);

Isso conduzirá a instância de uma classe Point, que foi atribuída a uma variável de nome p. O construvto de Point recebe os dois argumentos -1 e 65 e os atribui as variáveis de instância x e y respectivamente (compare sua definição em Class Instance (seção anterior)). Revisitaremo o significado exato da expressão new mais tarde na seção 5.12. Por ora, apenas pensamos nele como o constructor de classe e retornando o objeto apropriado.
 
\subsection{Herança}

Classes podem herdar de outras classes, o que em Haxe é indicado pela palavra-chave extends:

class Point3 extends Point{
   var z: Int;
   public function nes (x,y,z) {
      super(x,y);
      this.z = z;
   }
}

Essa relação é descrita como "é-um" (Point3 é um Point): Point então é chamado de pai (parent class) de Point 3, que é uma classe-filho de Point. Uma classe pode ter muitas classes filho, mas apenas uma classe pai. O termo "uma classe pai de X" geralmente se refere ao pai direto, mas também as classes pais dessas.

O código acima é bastante similar ao código original da classe Point, com dois novos constructs envolvidos:

- extends Point indica que a classe herda de classe Point

- super (x,y) é a chamada ao contrutror a classe pai, nesse caso Point.new

Não é necessário para as classes filho definirem seus próprios constructors, mas se o fizerem, uma chamada a super() é obrigatória. Não como outras linguagens orientadas a objeto, essa chamada pode aparecer em qualquer ponto do código do constructor e não tem que ser a primeira expressão.

Uma classe pode sobreescrever métodos (4.3) de sua classe pai, o que exige explicitamente a palavra chave override. Os efeitos e restrições do disso são detalhados adiante (Overriding Methods, 4.3.1)

2.3.3. Interfaces

Uma interface pode ser entendida como a assinatura de uma classe, porque ela descreve os campos públicos de uma classe. Interface não oferecem implementações, são puramente informações estruturais:

interface Printable {
    public funciton toString():String;
}

A sintaxe é similar a de classes, com as seguintes exceções:

- a palavra chave interface é usada ao invés da palavra-chave class

- funções não tem quaisquer expressões (68)

- todos os campos devem ter tipos explicitados

Interfaces, de forma diferente de subtipagem (3.5.2) descrevem uma relação estática entre as classes. Uma dada classe só é considerada compatível com uma interface se ela o declara explicitamente:

class Point implements Printable { }

Aqui, a palavra-chave implements denota que Point tem uma relação "é uma" com Printable, i.e., cada instância de Point também é uma instância de Printable. Enquanto uma classe só pode ter uma classe pai, ela pode implementar múltiplas interfaces atraves de múltiplas utilizações da palavra-chave implements:

class Point implements Printable
    implements Serializable

O compilador verifica se as premissas de implements existem. Isso é, ele garante que a classe implementa todos  os campos exigidos pela interface. Um campo é considerado implementado se a classe ou qualquer das suas classes pai oferece uma implementação.

Campos de interface não são limitados a métodos. Eles podem ser variáveis e propriedades também.

interface Placeable {
   public var x:Float;
   public var y:Float;
}

class Main implements Placeable {
   public var x:Float;
   public var y:Float;
}

class Main implements Placeable {
   public var x:Float;
   public var y:Float;
   static public function main(){ }
}

\triva{Sintaxe de Implements}{Versões do Haxe anteriores a 3.0 exigiam multiplas palavras-chave implements separadas por virgual. Decidimos aderir ao padrão de fato do Java e nos livramos da vírgula. Essa foi uma das notáveis mudanças entre Haxe 2 e Haxe 3.}

\section{Instância de Enum}

Haxe oferece poderosos tipos para enumeraçao (enum), que são na verdade tipos de dados algébicos (ADT algebraic data type). Ainda que não possam ter quaisquer expressões, eles são úteis pare descrever estruturas de dados:

enum Color {
Red;
Green;
Blue;
Rgb(r:Int, g:Int; b:Int);
}

Semanticamente, esse enum descreve uma cor que pode ser vermelho, verde, azul ou um valor Rgb específicado. A estrutura sintática é como segue:

- A palavra-chave enum indica que estamos declarando um enum.

- Color é o nome do enum, assim como qualquer palavra que se conforme com as regras para identificadores de tipos.

- Cercados pelas chaves estão os enum constructors,

- que são Red, Green e Blue sem argumentos.

- bem como Rgb com três argumentos Int: r, g e b.

O sistema de tipos do Haxe oferece um tipo que unifica com todos os tipos de  enum:

\definition{Type:Enum<T>}{Esse tipo é compatível com todos os tipos de enum. No momento de compilação, Enum<T> pode ser visto com um tipo base comum para todos os tipos de enum. No entanto, essa relação não é refeletida no código gerado}

\subsection{Enum Constructor}

Similarmente as classes e aos seus constructors, enums oferecem uma forma de instanciação utilizando um de seus construtores. Entretanto, diferente de classes, enums oferecem multiplos constructors que podem ser facilmente usados com o seu nome:

var a = Red;
var b = Green;
var c = Rgb(255,255,0);

Nesse código, o tipo de variável a,b e c é Color. A variável c é inicializada utilizando o constructor Rgb com argumentos.

Todas as instâncias de enum podem ser atribuídas a um tipo especial chamado EnumValue.

\definition{Type: EnumValue}{EnumValue é um tipo especial que unifica todas as instâncias de enum. É usado pela Biblioteca Padrão do Haxe para oferecer certas operações para todas as instâncias de enum e pode ser empregado em código-usuário de forma coerente em casos onde uma API exige uma instância de enum, mas não uma instância específica.

É importante se distinguir entre tipos enum e constructors de enum, como o exemplo mostra:

enum Color {
Red;
Green;
Blue;
Rgb(r:Int, g:Int; b:Int);
}

class Main {
   static public function main()  {
      var ec:EnumValue = Red // valid
      var en:Enum<Color> = Color; // valid
      // Erro: Color deveria ser Enum<Color>;
      // var x:Enum<Color> = Red;
   }
}

Se a marca de comentário da linha for removido, o porgrama não compila porque Red (um enum constructor) não pode ser atribuído a uma variável do tipo Enum<Color>(um tipo enum). A relação é análoga a uma classe e uma instância da classe.

\trivia{Parâmetro de tipo concreto para Enum<T>}{Um dos revisores desse manual ficou confuso sobre a diferença entre Color e Enum<Color> no exemplo acima. Corretamente, o uso de um parâmetro de tipo concreto ali é despropositado e serve apenas para demonstração. Usualmente nós poderíamos omitir o tipo ali e deixar a inferência de tipo tratar disso.

Entretanto, a inferência de tipo poderia ser diferente de Enum<Color>. O compilador infere um pseudo-tipo que tem os enum constructors como "campos". A partir do Haxe 3.2.0. não é possível expressar esse tipo de sintaxe, contudo nunca é necessário fazê-lo.}

\subsection{Usando enums}

Enums são uma boa escolha se somente um conjunto finito de valores é permitido. Os constructors inidividuais (subseção seguinte) então representam as variantes permitidas e habilitam o compilador a verificar se todos os possíveis valores são respeitados. Isso pode ser observado aqui:

enum Color {
Red;
Green;
Blue;
Rgb(r:Int, g:Int; b:Int);
}

class Main { 
   static function main() {
      var color = getColor();
      switch (color) {
         case Red: trace("Color was red");
         case Green: trace (Color was green");
         case Blue: trace (Color was green");
         case Rgb(r, g, b):
              trace (Color had a red value of " +r);
      }
}

static function getColor():Color{
   return Rgb(255, 0, 255);
}

Após registrar o valor de color atribuindo o valor de retorni de getColor() a ela, uma expressão switch pe usada para desvio em função do valor. Os primeiros três casos: Red, Green e Blue  são triviais e correspondem  aos constructors de Color que não tem argumentos. O caso final Rgb(r, g, b) mostra como os valores de um constructor podem ser extraídos, eles estão disponíveis como variáveis locais dentro do corpo da expressão do case, exatamente como se uma expressão var (5.10) tivesse sido empregada.

O uso avançado da expressão switch será explorado na seção de "casamento de padrões".

\subsection{Estruturas anônimas}

Estruturas anônimas podem ser usadas para agrupar dados sem a criação explicita de tipos. O exemplo a seguir  crua uma estrutura com dois campos: x e name, e inicializa seus calores para 12 e foo, respectivamente:

class Structure {
  static public function main() {
     var myStructure = {x:12, name:"foo"};
  }
}

A estrutura sintática geral é vista a seguir

1. Uma esturutra é cercada por chaves

2. Tem pares chave-valor separados por chaves

3. Dois pontos separam a chave, que deve ser um identificador válido (pg.68) do valor.

4. O valor pode ser qualquer expressão de Haxe

A regra quatro implica que as estruturas podem ser aninhadas  e complexas, por exemplo:

var user = {
   name: "Nicolas",
   age: 32,
   pos: [
    { x: 0, y: 0 },
    { x: 1, y: -1 },
 ],
};

Campos de estruturas, assim como classes, são acessados utilizando o ponto:

// retenha o valor do nome, que é "Nicolas"
user.name;
// faça o valor da idade ser 33
user.age = 33;

Vale apena observar que o uso de estruturas anônimas não subverte o sistema de tipos. O compilador assegura que apenas os campos disponíveis sejam acessados, o que implica que o programa seguinte não compila:

class Test {
   static public function main() {
     var point = { x:0.0, y:12.0};
     // { y: Float, x: Float} não tem campo z
     point.z;
   }   
}

A mensagem de erro indica que o compilador conhece o tipo de point: é uma estrutura com campos x e y de tipo Float. Já que não existe campo z, o acesso falha. O tupo de point é conhecido através de inferência de tipo, que graciosamente nos poupa do uso de tipos explicitos para variáveis locais. Como sempre, se point fosse um campo, tipificação explícita seria necessária:

class Path {
   var start : {x: Int, y: Int };
   var target : {x: Int, y: Int};
   var current : { x: Int, y: Int};
}

Para evitar essa redundância de declarações de tipo, especiamente para estruturas mais complexas é aconselhado o uso de typedef(3.1):

typedef Point = { x : Int, y : Int }

class Path {
    var start: Point;
    var target: Point;
    var current: Point;
}

\subsection {JSON para Estruturas de Valores (Structure Values)}

Também é possível usar JavaScript Object Notation para estruturas com o uso de string literals para as chaves:

var point {"x" : 1, "y" : -5};

Ainda que qualqure string literal seja permitido, o campo só é considerado parte do tipo se for um identificador válido do Haxe (pg 68). De outra forma, a sintaxe do Haxe não permite  forma de expressar o acesso ao campo, e reflection (10.6) tem que ser empregado através do uso de Reflect.field e Reflect.setField.

\subsection{Notação de classe para tipos de estrutura}

Quando se define um tipo de estrututa, o Haxe permite o uso da mesma sintaxe descrita em Campos de Classe (Capítulo 4). O seguinte typedef declara um tipo Point com os campos variáveis x e y do tipo Int:

typedef Point = {
var x : Int;
var y : Int;
}

\subsection{Impacto no desempenho}
O uso de estruturas e, por extensão, subtipagem de estruturas não tem impacto no desempenho quando compilado para targets dinâmicos. Entretanto, em targets estáticos uma procura dinâmica precisará ser feita, o que é tipicamente mais lento do que o acesso a um campo estático.

\section{Tipo Função}

O tipo função, junto com o tipo monomorfo(2.9) é um tipo que normalmente bem escondido dos usuários de Haxe, ainda que presente em todo lugar. Nós podemos fazê-lo surgir com o uso de $type, um identificador (identifier) especial do Haxe que expõe o tipo que uma expressçao tem durante a compilação:

class Function Type  {
    static public function main() {
        $type(test);           // i : Int -> s : String -> Bool
        $type(test(1,"foo"));  // Bool
}

   static function test(i:Int, s:String):Bool {
        return true;
   }
}

Há uma forte semelhança entre a declaração da função teste e o primeiro output da primeira expressão $type, mas também uma sutil diferença:

- Argumentos de função são separados por um token especial de seta -> ao invés de vírgulas e

- o tipo de retorno da função aparece ao final depois de outro ->.

Em qualquer uma das notações é óbvio que a função teste aceita um argumento do tipo Int e um segundo argumento do tipo String e retorna um valor do tipo Bool. Se uma chamada a essa função como test(1,"foo") é feita  dentro da segunda expressão, o tipificador do Haxe verifuca se 1 pode ser atribuído ao Int e se "foo" pode ser atribuído ao String. O tipo da chamada é então igualadi ai tipo do valor que test retorna, Bool.

Se um tipo função tem outro tipo função como argumento ou tipo de retorno, parenteses podem ser usados para agrupá-los corretamente. Por exemplo Int -> (Int -> Void) -> Void representa uma função cujo primeiro argumento é um Int, o segundo argumento é uma função (um tipo função) Int -> Void e o retorno é Void.

2.6.1 Argumentos Opcionais

Argumentos opcionais são declarados prefixando-se o identificador do argumento com um ponto de interrogação? :

class OptionalArguments{
    static public function main() {
      $type(test); // ?i : Int -> ?s : String -> String
      trace (test()); // i: null, s:null
      trace (test(1)); //i: 1, s:null
      trace (test(1,"foo")); // i:1, s: foo
      trace (test("foo")); // i:null, s:foo
    }
    
    static function test(?i:Int, ?s:String) {
      return "i: " +i + ", s: " +s;
    }
} 

\subsection{Default values}

O Haxe permite valores default para argumentos, atribuindo constantes a eles:

Valores default em Haxe não são parte do tipo e não são substituídos no local de chamada (a menos que seja uma função alinhada, ver 4.4.2), que podem ser consideradas como uma abordagem mais típica. Em alguns targets o compilador ainda pode passar null para valores de argumentos omitidos e gerar código similar a função seguinte:


Isso deve ser  considerado  em códigos em que o desempenho é crítico, onde a solução sem valores default pode ser mais viável algumas vezes.

\subsection{Dynamic}

Ainda que o Haxe tenha um sistema de tipos estático, esse sistema pode, efetivamente, ser desativado com o uso do tipo Dynamic. Um valor dinâmico pode ser atribuído a qualquer coisa, e qualquer coisa pode ser atribuída a ele. Isso tem inúmeras desvantagens:

- O compilador nçao pode mais verificar o tipagem nas atribuições, chamadas de funções e outros constructs onde tipos específicos são esperados.

- Certas otimizações, em particular quando compiladas para targets estáticos, não podem mais ser empregadas.

- Alguns erros comuns, e.g. um erro de digitação ao acesso de um campo não será pego no momento da compilação e provavelmente gerarão erros no momento de execução.

- A Eliminação de Código Morto (Seção 8.2) não poderá detectar campos utilizados se eles forem usados através de Dynamic.

É muito fácil chegar a exemplos onde o uso de Dynamic pode causar problemas no momento de execução. Considere a compilação das seguintes duas linhas de código:

var d:Dynamic = 1;
d.foo;

A tentativa de rodar um programa compilado em flash player provoca um erro Property foo not found on Number and there is no default value. (Propriedade foo não encontrada em Number e não há valor default.) Sem Dynamic, isso teria sido detectado no momento da compilação.

\trivia{Inferência de Dynamic antes do Haxe 3}{O compliador do Haxe 3 nunca infere um tipo como Dynamic, de forma que os usuários devem ser explícitos sobre isso. As versões anteriores do Haxe costumavam inferir arrays de tipos mistos, e.g. [1, true,"foo"], como Array<Dynamic>. Concluímos que esse comportamento trazia muitos problemas e o removemos para o Haxe 3.}

O uso de Dynamic deve ser minimizado, uma vez que existem opções melhores  em muitas situações em que sua utilização é só uma questão prática. Partes deo da API de Haxe Reflection (Seção 10.6) o utilizam e pe algumas vezes a melhor opção quando lidamos com estruturas de dados particularizadas que não são conhecidas no momento da compilação.

O tipo Dynamic se comporta de uma maneira especial quando está sendo unificado com um tipo monomorfo. Monomorfos nunca são impostos a Dynamics, o que pode ter resultados surpreendentes em exemplos como o abaixo:

class Main {
   static function main() {
      var jsonData = '[1, 2, 3];
      var json = haxe.Json.parse(jsonData);
      $type(json); // Unknown<0>
      for (i in 0 ... json.length) {
         trace (json[0]);
          // Acesso ao array não é permitido em
          // { + length : Int }
      }
   }
}

Ainda que o tipo do retorno de Json.parse seja Dynamic, o tipo da variável local é json não é imposto a ele e ele permanece um monomorfo. Ele é então inferido como uma estrutura anônima(2.5) sobre o acesso do campo json.length, o que causa que o seguinte acesso ao array em json[0] a falhe. Para evitar isso, a variável json pode ser explicitamente rotulada com tipo Dynamic usando var json:Dynamic.

\trivia{Dynamic na Biblioteca Padrão}{Dynamic era bem frequente na Biblioteca Padrão do Haxe antes do Haxe 3. Com as contínuas melhorias no sistema de tipos do Haxe, as ocorrências de Dynamic foram reduzidas nas novas versões que levaram ao Haxe 3.}

\section{Dynamic com parâmetros de tipo (Type Parameter)}

Dynamic é um tipo especial porque permite declaração explícita com e sem um parâmetro de tipo (). Se o parâmetro de tipo é fornecido, a semântica descrita em Dynamic (seção anterior) é restringida a todos os campos compatíveis com o tipo de parâmetro.

var att : Dynamic<String> = xml.atributes;
att.name = "Nicolas";// válido, o valor é um String
att.age = "26";// dito (essa documentação é bem velha)
att.income = 0; // erro, o valor não é um string

\subsection{Implementando Dynamic}

Classes podem implementar Dynamic e Dynamic<T>, o que habilita acessos de campos arbitrários. No primeiro caso, campos podem ter qualquer tipo, e no segundo eles são restritos à compatibilidade com o tipo de parâmetro.

class ImplementsDynamic
   implements Dynamic<String> {
   public var present:Int;
   public function new() {}
}

class Main {
   static public function main() {
   var c = new ImplementsDynamic();
   c.present = 1 // válido, present é um campo existente
   c.stringfield = "foo" // válido, o valor atribuído é um string
   c.intfield = 1; // erro, Int deveria ser String
}

A implementação de Dynamic não satisfaz os requerimentos de outras interfaces implementadas. Os campos esperados ainda tem que ser implementado explicitamente.

Classes que implementam Dynamic (com ou sem o parâmetro de tipo) tambpem podem utilizar um método especial chamado resolve. Se um acesso de leitura (4.2) é feito e o campo em questão não existe, o método resolve é chamado com o nome do campo como argumento.

class Resolve implements Dynamic<String> {
    public var present: Int;
    public function new() {}
    function resolve(field:String){
       return "Tried to resolve " + field;
    }
}

class Main {
    static public function main() {
       var c = new Resolve();
       c.present = 2;
       trace (c.present);
       trace (c.resolveMe);
    }
}




\Section{Abstract}
Um tipo abstrato (Abstract) é um tipo que é, na verdade, um tipo diferente em tempo de execução. É uma funcionalidade do compilador que define tipos "através" de tipos concretos de forma a modificar ou aumentar seu comportamento.

abstract AbstractInt(Int) {
    inline public function (i:Int) { 
        this = i;
    }
}

Nós podemos tirar o seguinte do exemplo:

- A palavra-chave abstract indica que estamos declarando um tipo abstrato.
- AbstractInt é o nome do tipo abstrato e poderia ser qualquer coisa que se conforme com as regras de identificadores de tipos.
- Dentro dos parenteses () está o tipo subjacente
- Dentro das chaves estão os campos,
- que são uma função de constructor new aceitando um argumento i do tipo Int.

\definition{Tipo subjacente (Underliyng Type)}{O tipo subjacente de um abstrato é o tipo que é usado para representá-lo em tempo de execução. É normalmente um tipo concreto (i.e. não abstrato), mas poderia ser um outro tipo abstrato igualmente.

A sintaxe é reminiscente de classes e a semântica é, de fato, similar. De fato, tudo que está no "corpo" de um abstrato (i.e. tudo depois da chave de abertura) é separado como campos de classe. Abstracts podem ter campos de método e campos de propriedades não-físicas.
Além do mais, abstracts podem ser instanciados e usados exatamente como classes.

class MyAbstract{
   static public function main() {
   var a = new AbstractInt(12)
   trace(a); //12
   }
}

Como foi mencionado antes, abstracts são uma funcionalidade para o momento de compilação, então é interessante observar o que o código acima gera na prática. Um target adequado para isso é Javascript, que tende a gerar código conciso e limpo. Compilando o acima (utilizando haxe -main MyAbstract -js myabstract.js) se obterá o seguinte código de Javascript:

var a =12;
console.log(a);

O tipo abstrato AbstractInt desapareceu completamente do resultado e tudo que permanece é o tipo subjacente, Int. Isso é porque o constructor de AbstractInt é alinhado (inline) - algo que devemos aprender a respeito adiante, na seção - e sua expressão alinhada atribui valor para this. O efeito pode ser surpreendente quando pensamos em termos de classes, entretanto, é precisamente o que queremos expressar no contexto de abstratos. Qualquer método membro alinhado de um abstrato pode atribuir valor par this, e assim modificar ovalor interno.

Uma boa pergunta nesse ponto é "O que acontece se uma função membro não for declarada alinhada (inline) porque o código obviamente precisa ir para algum lugar. O Haxe cria uma classe privada, conhecida como a classe de implementação; essa classe contem todas as funções abstratas membro como funções estáticas que aceitam o primeiro argumento adicional this do tipo subjacente. Ainda que isso seja tecnicamente um detalhe de implementação, pode ser usado para funções seletivas.

\trivia{Tipos Básicos e abstratos}{Antes do advento dos tipos abstratos, todos os tipos básicos era implementados como classes externas ou enums. Ainda que isso desse bem conta de alguns aspectos tais como Int ser uma classe filho de Float, causava problemas em outros lugares. Por exemplo, com Float sendo uma classe externa, ela unificaria a estrutura vazia {}, tornando impossível restringir um tipo a aceitar apenas objetos reais.}

\subsection{Casts implicitos}

(N. do T. A tradução etimologicamente correta de "cast" é "lançar", posteriormente em inglês o verbo assumiu o significado de "moldar" entre outros, advindo da utilização do termo para expressar objeto "lançado" (casted vira cast)), como em objetos de ferro fundido (cast iron) (broadcst se tornou difusão) a função computacional adquiriu o significado aproximado de converter, "enfiar" ou "meter" seriam traduções apropriadas a ideia, mas não soam bem em textos pretenciosos de precisão como esse. "Fusão" ou "fundição". Usaremos a forma não traduzida cast doravante)


Diferente de classes, abstratos permitem a definição de fusões implícitas. Há dois tipos de fusões implícitas:

Direta: Permite a fusão direta do tipo abstrato de ou para um outro tipo. Isso é definido adicionando regras to (para) e from(de) ao tipo abstrato e isso só é permitido  para tipos que se unifiquem com o tipo subjacente ao abstrato.

Campo classe: permite a fusão via chamadas a funções especiais de fusão que são definidas usando metadados @:from e @:to. Esse tipo de fusão é permitido para todos os tipos.

O exemplo de código a seguir mostra uma fusão direta:

abstract MyAbstract(Int) from Int to Int {
    inline function new(i:Int) {
        this = i;
    }
}

class ImplicitCastDirect {
    static public function main() {
       var a:MyAbstract = 12;
       var b:Int = a;
    }
}

Declaramos MyAbstract como sendo de Int e para Int, implicando que o tipo abstrato pode receber uma atribuição a partir de um Int e ser atribuído a um Int. Isso pe mostrado nas linhas 9 e 10, onde nós primeiro atribuímos o Int 12 a variável a do tipo MyAbstract (isso funciona devido a declaração from Int) e então o valor de um tipo abstrato é colocado de volta em uma variável do tipo Int, b (isso funciona devido a declaração Int).

Fusões pr campos classe tem a mesma semântica, mas são definidos de forma completamente diferente:

abstract MyAbstract(Int)  {
    inline function new (i:Int)  {
        this = i;
    }
    
    @:from
    static public function fromStrint(s:String)  {
        return new MyAbstract(Std.parseInt(s));
    }

   @:to
   public function toArray()  {
       return [this];
   }
}

class ImplicitCastField {
    static public function main () {
        var a:MyAbstract = "3";
        var b:Array<Int> = a;
        trace (b); // [3]
    }
}

Ao adicionar @:from a uma função estática, aquela função se qualifica como uma função de fusão do seu tipo de argumento para o tipo abstrato. Essas funções devem retornar um valor do tipo do abstrato. Elas também devem ser declaradas static.

Similarmente, adicionar @:to a uma função a qualifica como uma função implícita  do abstrato para o seu tipo de retorno. Essas funções são tipicamente funções membro, mas podem ser tornadas static e então servir como funções seletivas (2.8.4)

No exemplo, o método fromString permite a atribuição do valor "3" à uma variável do tipo MyAbstract enquanto o método toArray permite atribuir essa variável do tipo MyAbstract a uma variável b do tipo Array<Int>.

Quando se usa esse tipo de fusão, chamadas as funções de fusão são inseridas quando necessário. Isso se torna óbvio quando se olha para a exposição em Javascript:

var a = _ImplicitCastField.MyAbstract_Impl_.fromString("3");
var b = _ImplicitCastField.MyAbstract_Impl_.toArray(a);

Isso pode ser mais otimizado ao se alinhar as duas funções de fusão, tornando a exposição na seguinte:

var a = Std.parseInt("3");
var b = [a];

O algoritmo de seleção, quando atribui um tipo A para um tipo B com ao menos um deles sendo um tipo abstrato é simples:

1. Se A não é um abstrato, vá para 3.

2. Se A define uma "conversão-para" que admite B, vá para 6.

3. Se B não for um abstrato, vá para 5.

4. Se B define uma "conversão-de" que admite A, vá para 6.

5. Pare, unificação falhou.

6. Pare, unificação se sucedeu.

  Por concepção, fusões implícitas são não-transitivas, como o exemplo seguinte mostra:

abstract A(Int) {
    public function new () this = 0;
    @:to public function toB() return new B();
}

abstract B(Int) {
    public function new() this = 0;
    @:to public function toC() return new C();
}

abstrace C(Int) {
    public function new() this = 0;
}

class Main {
    static public function main() {
        var a = new A;
        var b:B = A; //válido, usa A.toB
        var c:C = b  //válido, usa B.toC
        var c:C = a  //erro, A deveria ser C
    }
}

Ainda que fusões individuais de A para B e de B para C sejam permitidas, uma fusão transitiva de A para C não é. Isso evita caminhos de fusão ambíguos e mantém um algoritmo de seleção simples.

\section{Sobreposição de operadores}

Abstracts permitem a sobreposição de operadores unários e binários ao se adicionar  o metadado @:op a um campo de classe

abstract MyAbstract(String) {
   public inline function new (s:String) {
   this = s;
   }

    @:op(A * B)
    public function repeat (rhs:Int):MyAbstract {
        var s:StringBuf = new StringBuf();
        for (i in 0...rhs)
            s.add(this);
        return new MyAbstract(s.toString());
    }
}

class AbstractOperatorOverload {
    static public function main()
       var a = new MyAbstract("foo");
       trace (a*3); //foofoofoo
    }
}

Ao definir @:op(A*B), a função repeat serve como um método operador para o operador de multiplicação * quando o tipo do valor a esquerda é um MyAbstract e o tipo do valor à esquerda é um Int. O uso é mostrado na linha 17, que por sua vez é convertida no abaixo, quando compilada para JavaScript

console.log(_AbstractOperatorOverload.
   MyAbstract_Impl_.repeat(a,3);

Similar às fusões implicitas (casts implícitos) nos campos de classe (2.8.1) uma chamada ao método sobreposto é inserida aonde necessário.

O exemplo da função repeat não é comutativo: Ainda que MyAbstract * Int funcione, Int * MyAbstract não funciona. Para que isso seja também seja permitido, o metadado @:comutative deve ser incluído. Caso deva funcionar apenas para Int * MyAbstract, mas não para MyAbstract * Int, a sobreposição do método pode ser feita de forma estática, aceitando Int e MyAbstract como primeiro e segundo tipos, respectivamente.

A sobreposição de operadores unários é analoga:

abstract MyAbstract(String){
    public inline function new (s:String) {
         this = s;
    }

    @:op(++A) public function pre()
       return "pre" + this;
    @:op(A++) public function post()
       return this + "post";
}

class AbstractUnopOverload {
    static public function main() {
       var a = new MyAbstract("foo");
       trace (++a); // prefoo
       trace (a++); // foopost
    }
}

Tanto operadores sobrepostos podem retornar qualquer tipo.

Também é possivel omitir o corpo do método de uma função @:op, mas apenas se o tipo subjacente do abstrato permitir a operação em questão e se o tipo resultante puder ser atribuído de volta ao abstrato.

\subsection{Acesso a Arrays}
(N do T: a opção mais apropriada em português para seria arranjo)

O acesso a arrays descreve a particular sintaxe tradicionalmente usada para acessar o valor em um array com um certo deslocamento (offset). Isso normalmente só é permitido com argumentos do tipo Int. Mesmo assim, com abstratos é possível definir métodos diferenciados de acesso a arrays. A biblioteca padrão do Haxe (Haxe Standard Library) usa  isso em seu tipo Map, onde os dois métodos seguintes podem ser encontrados:

@:arrayAcess public inline function
get(key:K) return this.get(key);
@:arrayAccess public inline function
arrayWrite(k:K, v:V):V {
    this.set(k,v);
    return v;
}

Existem dois tipos de métodos de acesso a Arrays:

  - Se um método @:arrayAccess aceita um argumento é um extrator (get)

  - Se um método @:arrayAccess aceita dois argumentos é um atribuidor (set)

Os métodos get e arrayWrite vistos acima permitem, então, os seguinte uso:

class Main {
    public static function main () {
       var map = new Map ();
       map ["foo"] = 1;
       trace(map["foo"]);
    }
}

Nessa altura, não deve ser surpreendente ver que chamadas aos campos do array sejam inseridas no resultado:

map.set("foo",1);
1;
console.log(map.get("foo"));

Resolução da ordem de acesso a arrays: Devido a um bug em versões do Haxe anteriores a 3.2 a ordem de verificação de campos :arrayAcess era indefinida. Isso foi consertado no Haxe 3.2 de forma que os campos são consistentemente verificados de cima para baixo:

abstract AString(String) {
    public function new(s) this.s;
    @:arrayAccess function getInt1(k:Int) {
        return this.charAt(k);
    }
    @:arrayAccess function getInt2(k:Int) {
        return this.charAt(k).toUpperCase(); //toUperCase=paraMaíuscula
    }
}

class Main {
    static function main() {
        var a = new AString("foo");
        trace a[0]; // f
    }
}

O acesso ao array a[0] é resolvido pelo campo getInt1, levando ao retorno da letra minúscula f. O resultado poderia ser diferente em versões anteriores ao Haxe 3.2

Campos que são definidos mais cedo tomam prioridade mesmo se eles exigirem um cast implícito.

\subsection{Funções Seletivas}

Já que o compliador promove funções membro dos abstratos a funções estáticas, é possível definir funções estáticas manualmente e usá-las sobre uma instância abstrata. A semantica aqui é similar àquelas das extensões estáticas, onde o tipo do argumento da primeira função determina para quais tipos a função é definida.

abstract MyAbstract<T>(T) from T {
    public function new(t:T) this = t;

    fuction get () return this;

    static public function
    getString(v:MyAbstract<String>):String {
        return v.get();
    }
}

class SeletiveFunction {
    static public function main() {
       var a = new MyAbstract("foo");
       a.getString();
       var b = new MyAbstract(1);
       b.getString(); // Não funciona: Int deveria ser MyAbstract<String> 

    }
}

O método getString do abstrato MyAbstract pe definido para aceitar o primeiro argumento de MyAbstract<String>. Isso faz com que ele esteja disponível na variável a na linha 14 (porque o tipo de a é MyAbstract), mas não esteja disponível na variável b, cujo tipo é MyAbstract<Int>.

\trivia{Funcionalidade Acidental}{Ao invés de ter sido deliberadamente concebidas, as funções seletivas foram descobertas. Depois que a ideia foi mencionada pela primeira vez, exigiu apenas alguns ajustes menores no compilador para fazê-las funcionar. Sua descoberta também levou a introdução dos abstratos multi-tipos, como o Map}

\subsection{Enums abstratos}

Desde o Haxe 3.1.0

Adicionando-se o metadado :enum à definição de um abstrato, esse abstrato pode ser usado para definir conjuntos finitos de valores:

@:enum 
abstract HttpStatus(Int) {
    var NotFound = 404; // Não Encontrado
    var MethodNotAllowed = 405; // Método não permitido
}

class Main {
    static public function main() {
        var status = HttpStatus.NotFound;
        var msg = printStatus(status);
    }

    static function
    printStatus(status:HttpStatus) {
        return switch(status) {
            case NotFound:
                "Não Encontrado";
            case MethodNotAllowed:
                "Método não permitido";
        }
    }
}

O compilador do Haxe substitui todos os acessos a campos do abstrato HttpStatus por seus valores, como fica evidente em seu resultado em Javascript:

Main.main = function() {
   var status = 404
   var msg = Main.printStatus(status);
};
Main.printStatus = function(status) {
    switch(status) {
    case 404:
        return 	"Não encontrado";
    case 405:
        return   "Método não permitido";
    }
};

Isso pe similar ao acesso de variáveis declaradas alinhadas, mas tem diversas vantagens:
   - O tipificador pode garantir que todos os valores do conjunto são corretos.
   - O localizardor de padrões (pattern matcher) verifica exaustivamente quando localiza um enum abstrato.
   - A definição de campos exige menos sintaxe.

\subsection{Repassando campos abstratos}

Desde o Haxe 3.1.0

Quando se envelopa um tipo subjacente, é algumas vezes desejável "manter" parte de suas funcionalidades. Por conta de ser pesaroso escrever o reencaminhamento de funções, o Haxe permite a adição do metadado :forward para um tipo abstrato:

@forward(push,pop)
abstract MyArray<S>(Array<S>) {
    public inline function new() {
        this = [];
    }
}

class Main {
    static public function main() {
        var myArray = new MyArray();
        myArray.push(12);
        myArray.pop();
        // MyArray<Int> não tem número de campos myArray.length
    }
}

O abstrato MyArray nesse exemplo envelopa Array. Seu metadado :forward tem dois argumentos que correspondem aos nomes de campos a serem repassados ao tipo subjacente. Nesse exemplo, o método main instancia MyArray e acessa seus métodos push e pop. A linha comentada mostra que o campo length não está disponível.

Como usualmente, podemos olhar prar o resultado em Javascript para ver como o código está sendo gerado:

Main.main = function() {
    var myArray = [];
    myArray.push(12);
    myArray.pop();
};

Também é possível usar :forward  sem argumentos de forma a repassar todos os campos. É claro que o compilador do Haxe assegura que o campo realmente exista no tipo subjacente.

\trivia{Implementado como macro}{As funcionalidades :enum e :forward foram originalmente implementadas usando macros de build. Ainda que isso funcionasse bem em um código sem macros, causava problemas se essas funcionalidades fossem usadas de dentro das macros. A implementação foi subsequentemente movida para o compilador.

\subsection{Abstratos de tipos do cerne(Core-type abstracts)}

A biblioteca padrão do Haxe (Haxe Standard Library) define um conjunto de tipos em seu cerne. Eles são identificados  pelo metadado :coreType e lhes falta uma declaração de tipo subjacente. Esses abstratos podem ainda ser entendidos como representantes de um tipo diferente. Ainda assim, esse tipo é nativo ao target do Haxe.

A inclusão de abstratos de tipos do cerne é raramente necessária em código usuário uma vez que exige que o target do Haxe consiga compreendê-lo. Entretanto podem haver casos de uso interessantes para autores de macros e novos targets do Haxe.

Em contraste ao abstratos opacos, abstratos de tipos do cerne tem as seguintes propriedades:

  - Não possuem tipo subjacente.

  - São considerádos nuláveis ao menos que sejam marcados com o metadado :notNull 

  - Tem permissçao para declarar funções de acesso a arrays sem expressões.

  - Campos de sobreposição de operadores que nçao tenham expressões não são forçados a aderir a semântica de tipos do Haxe.

 \section{Monomorfos}

Um monomorfo é um tipo que pode, através de unificação (ver), se modificar para um tipo diferente posteriormente. Devemos ver detalhes sobre esse tipo quando estivermos falando de inferência de tipos.


\Chapter{Type System}

Aprendemos sobre os diferentes tipos no Capítulo 2 e é chegado o momento de ver como eles interagem entre si. Começamos com facilidade introduzindo  typedef, um mecanismo para dar nomes (ou alias) a um tipo mais complexo. Entre outras coisas, isso será útil quando trabalharmos com tipos que tenham parâmetos de tipo.

Muito da segurança de tipos é conseguida através da verificação que dois dados tipos dos grupos de tipo já apresentados são compatíveis. Quer dizer, o compilador tenta aplicar unificação entre eles da forma detalhada em Unification (ver)
Todos os tipos são organizados em modulos e podem ser endereçados através de caminhos. Módulos e caminhos (ver seção) fornecerá uma explicação detalhada da mecânica envolvida.

\section{Typedef}

Nós olhamos rapidamente para typedefs quando falávamos de estruturas anônimas(seção) dando a elas um nome. Isso é precisamente para que servem bem os typedefs. Dar nome a tipos de estrutura pode ainda ser considerado seu uso primário. De fato, ossp é tão comum que a distinção parece um pouco difusa e muitos usuários de Haxe consideram typedefs como sendo a estrutura.

Um typedef pode dar nome para qualquer outro tipo:

typedef IA = Array<Int>;

Isso permite usar IA em lugares onde normalmente usaríamos Array<Int>. Ainda que isso economize apenas alguma digitação nesse particular caso, pode fazer uma diferençã muito maior para tipos mais complexos e compostos. Mais uma vez, essa é a razão por que typedefs e estruturas parecem tão conectados:

typedef User = {
    var age : Int;
    var name : Int;
}

Um typedef não é uma substituição de texto, mas um tipo real. Ele pode inclusive ter parâmetros de tipo (seção) como o tipo Iterable da biblioteca padrão do Haxe demostra:

typedef Iterable<T> = {
    function iteratos() : Iterator<T>;
}

\subsection{Extensões}

Extensões são usadas para expressar que uma estrutura tem todos os campos de um dado tipo bem como alguns campos próprios seus:

typedef IterableWithLength<T> = {
    > Iterable<T>, 
    // read only property
    var length(default,null):Int;
}

class Extension {
    static public function main() {
        var array = [1, 2, 3];
        var t:IterableWithLength<Int> = array;
    }
}

O operador maior > informa que uma extensçao de Iterable está sendo criada, com campos de classe adicionais seguintes. Nesse caso, uma propriedade somente-leitura length do tipo Int é necessária.

De forma a ser compatível com IterableWithLength<T>, um tipo deve então ser compatível com Iterable<T> e também oferecer uma propriedade apenas-leitura do tipo Int. O exemplo atribui Array, que apensa preenchem esses requerimentos

Também é possível estender multiplas estruturas:

typedef WithLength {
    var length(default,null):Int;
}

typedef IterableWithLengthAndPush<T> = {
    > Iterable<T>,
    > WithLength,
    function push(a:T):Int;
}

class Extension2 {
    static public function main() {
        var array = [1, 2, 3];
        var t:IterableWithLenghtAndPush<Int> = array;
    }
}

O array é um Type (Ver classe Array e Iterable na biblioteca padrão... o array só exibirá a definição dele e a documentação, mas não a implementação: a implementação é para cada um dos targets) que tem HasNext, Length e uma função push com a assinatura definida na linha 8

\subsection Parâmetros de Tipo

O Haxe permite a parametrização de diverso tipos, bem como de campos de classe (ver capítulo) e constructors de enums (ver subseção). Parâmetros de tipo são definidos entre sinalizadores angulares <>, separados pro vírgulas. Um exemplo simples da biblioteca padrão do Haxe é o Array:

class Array<T> {
        function push(x:T) : Int;
}

Em toda ocasião que uma instância de Array é criada, seu parâmetro de tipo T se torna um monomorfo (ver seção). Isso é, ele pode ser amarrado a qualquer tipo, mas apenas um de cada vez. Essa amarração pode acontecer

explicitamente através da invocação do contructor com tipos explicitos (new Array<String>() ) ou

implicitamente através da inferência de tipos, e.g. na invocação de arrayInstance.push("foo").

Dentro da definição de uma classe com parâmetros de tipo, esses tipos de parâmetro são de uma tipo não específico. Ao menos que restrições (ver subseção) sejam adicionadas, o compilador tem que assumir que os tipos de parâmetros poderiam ser usados com qualquer tipo. Como consequência, não é possívelcruar uma nova instância de um parâmetro de tipo a menos que o parâmetro de tipo seja genérico (ver seção) e restrito de acordo com isso.

A seguinte tabela mostra onde parâmetros de tipo são permitidos:

Parâmetro - Momento de amarração
Classe - intanciação  Também pode ser amarrada aos acessos de campos membros
Enum - instanciação
Enum constructor - instanciação
Função - invovação - Permitido para métodos e funções locais lvalue nomeadas
Estrutura  - intanciação

Com parâmetros de tipo de função sendo amarrados no momento da invocação, tais parâmetros de tipo (se não restrito) aceita qualquer tipo. Entretanto, apensas um tipo de invocação por tipo é aceito. Isso pode ser utilizado se uma função tem múltiplos argumentos:

class FunctionParameterType {
    static public function main() {
        equals (1, 1);
        // mensagem em tempo de execução: bar should be foo
        equals ("foo","bar");
        // erro de compilação: String should be Int
        equals (1, "foo");
    }

    static function
    equals<T>(expected:T,actual:T) {
        if (actual != expected {
            trace('$actual should be $expected');
        }
    }
}

Ambos argumentos: expected e actual da função equals tem o tipo T. Isso implica que para cada invocação de equals os dois argumentos devem ser do mesmo tipo. O compilador admite a primeira chamada (ambos os argumentos são do tipo Int) e a segunda chamada (ambos argumentos são do tipo String), mas a terceira tentativa  causa um erro de compilação.

\trivia{Parâmetros de tipo na sintaxe de expressões}{Muitas vezes somos questionados sobre o porquê de um método com parâmetros de tipo não poderem ser chamados como method<String>(x). As mensagens de erro que o compilador dá não são muito úteis. Entretanto, há uma razão simples para isso: O código acima é processado  como se ambos < e > fossem operadores binários, fornecendo (method < String) > (x).}

\subsection{Restrições}

Parâmetros de tipo podem ser restritos a múltiplos tipos:

typedef Measurable = {
    public var lenght(default,null):Int;
}

class Constraints {
    static public function main() {
        trace(test([]));
        trace(test(["bar","foo"]));
        // String deveria ser Iterable<String>
        // test("foo");
    }

    static function
        test<T:(Iterable<String>, Measurable)>(a:T) {
        if (a.length == 0) return "vazio";
        return a.iterator().next();
    }
}

O parâmetro de tipo do método test é restrito aos tipos Iterable<String> e Measurable.  O último é definido usando um typedef(ver seção) por conveniência e exige que tipos compativeis tenham uma propriedade somente-leitura (4.2) chamada Length do tipo Int.

 As restrições indicam então que um tipo é dito compatível se:

  - For compatível com Iterable<String> e

  - Tiver uma propriedade length do tipo Int.

Nós podemos ver que ao invocar test com um array vazio na linha 7 e com um Array<String> na linha 8 funciona bem. Isso é porque Array tem tanto um a propriedade lenght quanto um método iterador. Entretanto, ao passar um argumento String na linha 9 falha na verificação de restrição porque String não é compatível com Iterable<T>.

\section{Genérico}

Usualmente, o compilador do Haxe gera apenas uma única classe ou função mesmo que ela tenha parâmetros de tipo. Isso resulta em uma abstração natural onde o gerador de código para a linguagem target tenha que assumir que um parâmetro de tipo possa ser de qualquer tipo. O código gerado deve, então, pser capaz de desempenhar algumas verificações de tipo que podem acontecer em detrimento do desempenho.

Uma classe ou função pode ser tornada genérica pela atribuição do metadado :generic (ver seção). Isso faz com que o compilador emita uma classe/função distinta por combinação de parâmetros de tipo com nomes concatenados. Uma especificação como essa pode conceder uma melhora em porções críticas de código em targets estáticos (ver seção) ao custo de um código resultante mais extenso:

Código

Parece incomum ver o tipo explícito MyArray<String> aqui, porque normalmente deixamos a inferência de tipos tratar disso. Ainda assim, nesse caso é realmente necessário. O compilador precisa saber o tipo exato da classe genérica para a construção. O código em Javascript evidência o resultado


Código

Podemos identificar que MyArray<String> e MyArray<Int> se tornaram MyArray_String e MyArray_Int respectivamente. Isso é similar em funções genéricas:

Código

Novamente, o código em Javascript torna isso óbvio:

Código

\subsection{Construção de parâmetros de tipo genéricos}

\definition{Parâmetro de Tipo Genérico}{Um parâmetro de tipo é dito genérico se a classe ou método que o contém é genérica}

Não é possível consturi parâmetros de tipo normais, por exemplo new T() é um erro de compilação. A razão para tanto é que o Haxe gera apenas uma função e o construct não faz sentido nesse caso. Issi pe diferente quando o parâmetro de tipo é genérico: desde que saibamos que o compilador gerará uma função distinta para cada combinação de parâmetro de tipo, é possível substituir o new T() com tipo real.

Código

Deve ser observado que inferência de cima para baixo (ver subseção) é usada aqui para determinar o real tipo de T. Há duas exigências para esse tipo de construção de parâmetro de tipo funcionar: O parâmetro de tipo construído deve ser:

   1. Genérico e
   2. se explicitamente restrito (ver subseção) em ter um constructor (ver subseção).

Aqui, 1. é dado por make make tem um metadado @:gereic, e 2. por restringir T a Constructible. A restrição aceita tanto String quanto haxe.Template, pois ambos tem um constructor que aceita um único argumento String. Certamente, o Javascript resultante parece com o esperado:

Códgo

\subsection{Variância}

Ainda que variância seja relevante em outros locais, ela ocorre com frequência especialmente em parâmetros de tipo e aparece como uma surpresa nesse contexto. Adicionalmente, é muito fácil disparar erros de variância:

class Base {
    public function new() {}
}

class Child extends Base {}

class Main {
    public static function main() {
       var children = [new Child()];
       // Array<Child> deveria ser Array<Base>
       // Parâmetros de tipo são invariantes
       // Child deveria se Base
       var bases:Array<Base> = children;
    }
}

Aparentemente, um Array<Child> não pode ser atribuído a um Array<Base>, mesmo que Child possa ser atribuída à Base. A razão para isso pode ser um pouco inesperada: não é possível porque é possível escrever em arrays, e.g, via o método push(). É fácil  gerar problemas ao se ignorar erros de variância

class Base {
    public function new() { }
}

class Child extends Base  { }

class OtherChild extends Base { }

class Main  {
    public static function main()  {
        var children = [new Child()];
        // subverte verificador de tipo
        var bases:Array<Base> = cast children;
        bases.push(new OtherChild());
        for (child in children) {
            trace(child);
        }
    }
}

Aqui nós subvertemos o verificador de tipos ao usar cast (ver seção), assim permitindo a atribuição da linha 12. Com isso, nós mantivemos uma referência de bases ao array original, tipado como Array<Base>. Isso permite o push de um outro tipo compatível com Base(OtherChild) naquele array. Entretanto, nossa referência original children ainda é um tipo de Array<Child> e as coisas irão mal quando encontrarem a instância de OtherChild em um de seus elementos  durante a iteração.

Se Array não tivesse o método push() e nenhuma outra forma de modificação. a atribuição seria segura porque nenhum tipo incompatível seria adicionado a ela. No Haxe, nós podemos conseguir isso através da adequada restrição, usando a subtipagem estrutural (ver seção):

class Base {
    public function new () { }
}

class Child extends Base { }

typedef MyArray<T> = {
    public function pop():T;
}

class Main {
    public static function main() {
    var a = [new Child()];
    var b:MyArray<Base> = a;
    }
}

Nós podemos tranquilamente atribuir com b sendo tipado como MyArray<Base> e MyArray tendo apenas um método pop(). Não há nenhum método definido sobre MyArray que pudess ser usado para adicionar tipos incompátiveis; ele é então dito covariante.

\definition{Covariante}{Um tipo composto é considerado covariante se seus tipos componentes podem ser atribuídos a componentes menos específicos, i.e. se eles só podem ser lidos, mas nunca escritos.}

\definition{Contravariante}{Um tipo composto é considerado contravariante se seus tipos componentes podem ser atribuídos a componetes menos genéricos,i.e. se eles só são escritos e nunca lidos.}

\subsection{Unificação}

Unificação é o coração do sistema de tipos e contribui imensamente para a robustez dos programas em Haxe. Ela descreve o processo de verificação de compatibilidade entre os tipos.

\definition{Unificação}{A unificação entre dois tipos A e B é um processo direcional que responde se A pode ser atribuído a B. Ela pode modificar algum dos dois tipos se ele for ou tiver um monomorfo (ver seção)}

Erros de unificação são fáceis de desengatilhar:

class Main {
    static public function main() {
    // Int deveria ser String
        var s:String = 1;
    }
}

Nós tentamos atribuir um valor do tipo Int para uma variável do tipo String, o que leva o compilador a tentar unificar Int com String. Isso é, naturalmente, não permitido e faz com que o compilador envie o erro Int should be String.

Nesse caso particular, a unificação é disparada por uma atribuição, um contesto no qual a definição "é atribuível a" é intuitiva. Esse é apensas um dos diversos casos em que se executa a unificação:

Atribuição: se a é atribuído a b, o tipo de a é unificado com o tipo de b

Chamada de função: Nós vimos rapidamente esse caso enquanto apresentávamos o tipo função. Em geral o compilador tenta unificar o tipo do primeiro argumento passado com tipo o primeiro argumento esperado, o tipo do segundo argumento passado com otipos do segundo argumento esperado e daí em diante atée que todos os tipos dos argumentos tenham sido tratados.

Retorno de função: Sempre que uma função tiver uma expressão de retorno e, o tipo de e é unificado com tipo de retorno da função. Se a função não tem um tipo explicíto de retorno, ele é inferido como sendo do tipo de e - e as expressões subsequentes desse retorno são inferidas em relação a ele.

Declaração de Array: O compilador tenta achar o tipo mínimo entre todos os dados tipos em uma declaração de array. Veja Tipos Base Comuns (ver seção) para detalhes.

Declaração de Objetos: Se um objeto é declarado "sobre" um dado tipo, o compilador unifica o tipo de cada campo esperado.

Unificação de operadores: Certos operadores esperam certos tipos, em relação aos quais os tipos são unificados.

\subsection{Entre Classe/Interface}

Quando se define o comportamento de unificação entre classes, é importante se lembrar que a unificação é direcional: Nós podemos atribuir uma classe mais especializada (e.g. uma classe filho) a uma classe genérica (e.g. uma classe pai), mas o contrário não é válido.

As seguintes atribuições são permitidas:

  - classe filho a classe pai

  - classe a interface que a implementa

  - interface para interface base

Essas regras são transitivas, impolicando que uma classe filho também pode ser atribupida a classe base de sua classe base, uma interface que sua classe base implementa, a interface base de uma interface que a implementa e assim por diante.

\subsection{Subtipagem Estrutural}

\definition{Subtipagem Estrutural}{Subtipagem estrutural define um relação implícita entre tipos que tem a mesma estrutura}

No Haxe, a subtipagem estrutural só é possível quando a se atribui uma instância de classe a uma estrutura. O exemplo seguinte é parte da classe Lambda da biblioteca padrão(ver Capítulo):

public static function
empty<T>(it: Iterable<T>):Bool {
    return !it.iterator().hasNext();
}

O método-vazio verifica se um Iterable tem um elemento. Com esse propósito, não é necessário saber nada a respeito do tipo do argumento, qye não o fato de ser considerado iterável. Isso permite chamar o método-vazio com qualquer tipo que unifique com Iterable<T>, o que se aplica a muitos tipos da biblioteca padrão.

Essa espécie de tipagem pode ser muito conveniente, mas o uso excessivo pode causar detrimento de desempenho, o que é detalhado em Impactos sobre o desempenho (ver seção).

\subseção{Monomorfos}

Unificação de tipos que sejam ou contenham monomorfos (ver seção) é detalhado em Inferência de Tipos (ver seção).

\subseção{Retorno de Função}

A unificação dos tipos de retorno de funções pode envolver o tipo-Void (ver seção) e exige uma clara definição do que se unifica com Void. Sendo Void a descrição de ausência de tipo, ele não pode ser atribuído a nenhum outro tipo, nem mesmo Dynamic. Isso implica que se uma função é explicitamente declarada como retornando um Dynamic, ela não pode retornar Void.

O oposto também se aplica: Se uma função declara um tipo de retorno Void, ela não pode retornar Dynamic ou qualquer outro tipo. Entretanto, essa direção de unificaçãoé permitida quando se atribui a tipos de função:

var func:Void->Void = function() return "foo";

O lado direito da função é claramente do tipo Void->String, ainda assim é possível atribuí-la a variável do tipo Void->Void. Isso porque o compilador pode tranquilamente assumir que o tipo do retorno é irrelevante, dado o fato que ele não pode ser atribuído a nenhum tipo não-Void.

\subsection{Tipos Base Comuns}
 
Dado um conjunto de múltiplos tipos, um tipo base comum é um tipo ao qual todos os tipos do conjunto se unificam:

class Base  {
    public function new()  { }
}

class Child1 extends Base { }
class Child2 extends Base { }

class UnifyMin {
    static public function main() {
        var a = [new Child1, new Child2()];
        $type(a); // Array<Base>
    }
}

Ainda que Base não seja mencionada, o compilador do Haxe é capaz de inferir que o tipo comum a Child1 e Child2. O compilado do Haxe emprega esse tipo de unificação nas seguintes situações:

   - declaração de array
   - if/else
   - cases em um switch

\section {Inferência de tipos}

Os efeitos da inferência de tipos foram vistos ao longo de todo ese documento e continuarão a ser importantes. Um simples exemplo mostra a inferência de tipos funcionando:

class TypeInference {
    public static function main() {
        var x = null;
        $type(x); // Unknown<0>
        x = "foo";
        $type(x); // String
    }
}

O construct especial $type foi mencionado anteriormente de forma a simplificar a explicação do tipo função (ver seção), então, permita-nos apresentá-lo oficialmente:

\definition{Construct: $type}{$type é um mecanismo do momento de compilação sendo chamado como uma função, com um simples argumento. O compilador calcula o valor da expressão passada como argumento e então exibe o tipo daquela expressão.}

No exemplo acima, a primeiro $type imprime Unknown<0>. Isso é um monomorfo, um tipo que ainda não é conhecido. A próxima linha x = "foo" atribui um literal String a x, o que gera a unificação do monomorfo com String. Quando se vê, então, o tipo de x, de fato, mudou para String.

Sempre que um tipo, que não Dynamic, é unificado com um monomorfo, aquele monomorfo se torna aquele tipo: ele se morfa naquele tipo. Assim ele não pode morfar em um tipo diferente mais tarde, uma propriedade expressa na parte mono de seu nome.

Seguindo as regras de unificação, a inferência de tipos pode ocorrer em tipos compostos:

class TypeInference2 {
    public static function main() {
        var x = [];
        $type(x); // Array<Unknown<0>>
        x.push("foo");
        $type(x); // Array<String>
    }
}
A variável x é primeiro inicializada em um array vazio. Nesse ponto podemos dizer que o tipo de x é um array, mas não sabemos ainda o tipo dos elementos do array. Consequentemente, o tipo de x é Array<Unknown<0>>. É somente depois de enfiar um String dentro do array qye nós conseguimos saber que o tipo será Array<String>;

\subsection {Inferência de cima para baixo}

A maior parte do tempo, tipos são inferidos por si sós e devem então ser unificados com um tipo esperado. Em uns poucos lugares, no entanto, um tipo esperado pode ser usado para influenciar a inferência. Quando se fala em inferência de cima para baixo.

\definition{Tipo Esperado}{Tipos Esperados ocorrem quando o tipo de uma expressão é conhecido antes da expressão ser tipada, e.g., porque a expressão é um argumento a uma chamada de função. Elas podem influenciar a tipagem daquela expressão através do que é chamado de inferência de cima para baixo.}

Um bom exemplo são arrays de tipos mistos. Como mencionado em Dynamic (ver seção), o compilador recusa [1,"foo"] porque ele não consegue determinar o tipo do elemento. Ao empregar inferência de cima para baixo o seguinte pode passar:

class Main {
    static public function main () {
       var a:Array<Dinamic> = [1, "foo"];
    }
}

Aqui o compilador sabem ao tipar [1,"foo"] que o tipo esperado é um Array<Dynamic>, então o tipo do elemento é Dynamic. Ao invés do comportamento de unificação usual, o compilador tentaria (e falharia) determinar uma base de tipo comum (ver seção), os elementos individuais são tipados e unificados em relação ao Dynamic.

Vimos um outro uso interessante de inferência de cima para baixo quando a construção de parâmetros de tipo genéricos foi apresentada:

código

Os tipos explicitos  String e haxe.Template são usados aqui para determinar o tipo de retorno de make. Isso funciona porque o método é chamado como make(), de forma que o tipo do retorno será atribuído às variáveis. Com a utilização dessa informação é possível amarrar o tipo desconhecido T a String e a haxe.Template respectivamente.

\subsection{Limitações}
A inferência de tipos evita um monte de trabalho manual quando se trabalham com variáveis locais, mas algumas vezes o sistema de tipos ainda precisa de alguma ajuda. De fato, ele nem sempre tenta inferir o tipo de um campo variável (ver seção) ou de um campo propriedade (ver seção) a não ser que ele tenha inicialização direta.

Existem também alguns casos envolvendo recursçao onde a inferência de tipos tem limitações. Se uma função se chama recursivamente enquanto seu tipo não é (completamente) conhecido aina, a inferência de tipo pode inferir, erroneamente, um tipo muito especializado.

Um diferente jeito de limitação envolve a legibilidade do código. Se a inferência de tipos é abusada, pode se tornar difícil de entender partes de um programa devido a lacuna de tipos visíveis. Isso é particularmente verdade para assinatura de métodos. É recomendado se encontrar um bom equilíbrio entre a inferência de tipos e asserções. 

\subsection{Módulos e Caminhos}

\definition{Módulo}{Todo o código em Haxe é organizado em módulos, que são endereçãos usando caminhos. Em essência, cada arquivo .hx representa um módilo que pode conter diversos tipos. Um tipo pode ser privado (private), caso em que somente o módulo que o contém pode acessá-lo.}

A distinção de um módulo e o tipo que ele contém com o mesmo nome é nebulosa por concepção. De fato, o enderçamento haxe.ds.String<Int> pode ser considerado um encurtamento para haxe.ds.StringMap.StringMap<Int>. Esse último consiste de quatro partes:

1. o pacote haxe.ds

2. o nome do módulo StringMap

3. o nome do tipo StringMap

4. o parâmetro do tipo Int

Se o nome do módulo e do tipo são iguais, a duplicação pode ser removida, levando a versão curta haxe.ds.StringMap<Int>. Entretanto, o conhecimento sobre a versão longa ajuda no entendimento sobre como subtipos de módulo são tratados.

Caminhos podem ser encurtados ainda mais pelo uso de import (ver seção), o que tipicamente permite a omissão da parte do pacote de um caminho. Isso pode levar ao uso de identificadores sem qualificação do caminho, par o que é necessário entender a ordem de resolução (ver seção).

\definição{Caminho do tipo}{O caminho (por pontos) de um tipo consiste de um pacote, o nome do módulo, e o nome do tipo. A sua forma geral é pack1.pack2.packN.NomedoMódulo.NomedoTipo.

\subsection{Subtipos de módulo}

Um subtipo de módulo é um tipo declarado em um módulo que tenha o nome diferente do módulo. Isso permite que um único arquivo .hx contenha multiplos tipos, que podem ser acessados sem qualificação de dentro do módulo e usando a form package.Module.Type a partir de outros módulos:

var e:haxe.macro.Expr.ExprDef;

Aqui, o subtipo ExprDef dentro do módulo haxe.macro.Expr é acessado.

A relação do subtipo não é refletida em tempo de execução. Isso é, subtipos públicos se tornam membros do pacote que os contém, o que pode levar a conflitos se dois módulos com o mesmo pacote tentarem definir o mesmo subtipo. Naturalmente, o compilador do Haxe detecta esses casos e os relata adequadamente. No exemplo acima ExprDef é gerado como haxe.macro.ExprDef.

Subtipos também podem ser feitos privados:

private class C {...}
private enum E {...}
private typedef T {...}
private abstract A {...}

\definition{Tipo privado}{Um tipo pode ser feito provado com uso do modificador private. Como resultado, o tipo só pode ser acessado diretamente de dentro do módulo em que foi definido.

Tipos privados, diferentemente dos públicos, não podem se tornar membros do pacote que os contém.}

A acessibilidade dos tipos pode ser controlada  com mais granulosidade pelo uso de controles de acesso (ver seção).

\subsection{Import}

Se um caminho de tipo é usado múltiplas vezes em um arquivo .hx, pode fazer sentido usar um import para encurtar o seu nome. Isso permite omitir o pacote quando se utilizar o tipo:

import haxe.ds.StringMap;

class Main {
    static public function main() {
    // ao invés de: new haxe.ds.StringMap()
    new StringMap;
}

Com haxe.ds.StringMap sendo importado na primeira linah, o compilador é capz de resolver o identificador sem qualificação StringMap na função main desse pacote.

Nesse exemplo, nós estamos de fato importando um pacot, não simplesmente um tipo específico dentro daquele módulo. Isso implica que todos os tipos definidos dentro do módulo importado estão disponíveis:

import haxe.macro.Expr;

class Main {
    static public function main()   {
        var e:Binop = OpAdd;
    }
}

O tipo Binop é um enum (ver seção) declarado no módulo haxe.macro.Expr, e portanto disponível depois do import do dito módulo. Se fôssemos importar apenas um tipo específico daquele módulo, por exemplo, import haxe.macro.Expr.ExprDef, o programa iria falhar na compilação com Class not found: Binop.

Há diversos aspectos que valem a pena serem conhecidos sobre importações:

 - O último import tem prioridade (detalahdo em Ordem de Resolução (ver seção))

 - A palavra-chave de extensão estática "using" implica nos efeitos de "import".

 - Se um enum é importado (diretamente ou como parte de um import de módulo), todos os seus constructors (ver seção) também são importados (isso é o que permite que OpAdd seja utilizado no exemplo anterior).

Além disso, também é possível importar campos estáticos (ver) de uma classe e utilizá-los sem qualificação:

import Math.random;

class Main {
   static public function main() {
      random();
   }
}

Cuidado especial deve ser tomado com nomes de campos ou variáveis locais que conflitem com um nome de pacote: Uma vez que eles tem prioridade sobre os pacotes, uma variável local chamada haxe bloqueia o uso de todo o pacote haxe.

\subsection{Ordem de Resoluçã}

A ordem de resolução entra em ação assim que identificadores sem qualificação estejam envolvidos. Esses são expressões (ver capítulo) no formato foo(),foo =1 e foo.field. Essa última, em particular, inclui caminhos de módulo tais como haxe.ds.StringMap, onde haxe é um identificador sem qualificação.

Descrevemos o algoritmo de ordem de resolução aquim que dependem dos seguintes estados:

  - as variáveis locais declaradas (ver seção) (incluindo argumentos de função)

  - os módulos, tipos e estáticos importados (ver seção)
 
  - as extensões estáticas disponíveis

  - a espécie (estática ou membro) do campo atual

  - os campos membros declarados da classe atual e de suas classe pai

  - os campos estáticos declarados na classe atual

  - o tipo esperado

  - a expressão sendo untyped ou não.

Dado um identificador i, o algoritmo é como se segue:

1. Se i é true, false, this, super ou null, resolva i como a constante indicada e pare.

2. Se uma variável local chamada i é acessível, resolva como essa variável pare

3. Se o campo atual é estático, vá para 6.

4. Se a classe atual ou qualquer de suas classe pai tem um nome de campo i, resolva como esse campo e pare

5. Se uma extensão estática  com um primeiro argumento do tipo da classe atual estiver diponível, resolva como ela e pare.

6. Se a classe atual tem um campo estático chamado i, resolva como esse campo e pare.

7. Se um constructor de enum chamado i é declarado em um enum importado, resolva como ele e pare.

8. Se um estático chamado i é explicitamente importado, resolva como ele e pare.

9. Se i começar com um caractere minúsculo, vá para 11.

10. Se um tipo chamado i está disponível, resolva como ele e pare.

11. Se a expressão não está em modo untyéd, vá para 14.

12. Se i for igual a __this__, resolva como a constante this e pare.

13. Gere yma variável local chamada i, resolva como esta variável e pare.

14. Chame uma falha

Par o passo 10, também é necess[ario definir uma resolução de ordem de tipos:

1. Se o tipo chamado ié importado (diretamente ou como parte de um módulo), tesolva como ele e pare.

2. Se o pacote atual contém um módulo chamado i com um tipo chamado i, resolvacom o tipo e pare.

3. Se um tipo chamado i estiver disponível em níveis superiores, resolva como ele e pare.

4. Chame uma falha;

Para o passo 1 desse algoritmo também para os passos 5 e 7 do anterior, a ordem de resolução dos import também é importante:

  - Módulos importados e extensões estáticas são verificadas de cima para baixo com a primeira coincidência sendo escolhida.

   - Dentro de um dado módulo, tipos são checados de cima para baixo.

   - Para imports, uma coincidência é considerada se o nome é igual

   - Para extensões estáticas, uma coincidência é considerada se o nome é igual eo primeiro argumento unifica. Dentro de um dado tipo sendo utilizado como uma extensão estática, os campos são checados de cima para baixo.


\chapter{Campos de classe}

Deixa de ser tradução do Manual e passam a ser uma livre tradução, eventualmente mais incompleta e/ou com o meu entendimento.

Um campo da classe é uma variável, propriedade ou método de uma classe, i.e., as declarações que se encontram dentro das chaves na declaração da classe.

Existe o modificador static

Campos não estáticos são tratados como campos "membros da classe"

Até aqui o manual tratou de tipos e da estrutura geral dos programas em Haxe. Essa seção conclui o assunto e faz uma ponte para o comportamento da linguagem. Isso porque os campos das classes são o local natural das expessões, assunto do pŕoximo capítulo.

Variáveis: guardam valores de um certo tipo, podem ser lidas e alteradas.

Propriedade: definem a forma de acesso a algo que, de fora da classe, parece como um campo variável da classe.

Método: É uma função que pode ser chamada para executar código.

Variáveis podem ser vistas como propriedades com certos modificadores de acesso. O Haxe não diferencia variáveis de propriedades durante a fase de tipagem, mas elas permanecem separadas em nível de sintaxe.

Terminologia: Um método é uma função (seja estática ou não) que pertence a uma classe. Outras funções, como funções locais em expressões, não são considerados métodos.

\section{Variáveis}

Já vimos campos "variáveis" em vários exemplos nas seções anteriores. Variáveis detém valores, uma caracterísitica compartilhada com a maioria (mas não todas) propriedades:

class VariableField {
    static var member:String = "bar";

    public static function main() {
        trace(member);
        member = "foo";
        trace(member);
    }   
}

Variáveis:

1. tem um nome (no caso member)

2. tem um tipo (no caso String)

3. Podem ter uma inicialização como constante (no caso "bar")

4. Podem ter modificadores de acesso (no caso:static)

O exemplo inicializa o valor de membro, o imprime, o altera e o imprime de novo. O efeito de modificadores de acesso é partilhado pelas três espécies de campos e são explicados em uma seção a parte.

Deve se observar que um tipo explícito não é necessário se há um valor de inicialização. O compilador fará a inferência nesse caso.

Gráfico mostrando possíveis inicializações de uma variável de classe
(ver depois que entender o que é inline, extern e static)

\section{Propriedades}

Depois de váriáveis, propriedades são a segunda opção para manipular dados em uma classe. 

Propriedades oferecem maior controle sobre que tipo de acesso ao campo pode ser permitido e como ele é gerado. Casos comuns incluem os seguintes:

- Ter um campo que possa ser lido de qualquer lugar, mas só possa ser alterado de dentro da classe que o definde

 - Ter um campo que chama um método que extraia informações (getter) por ocasião do acesso de leitura.

 - Ter um campo que chama um método para alterar informações (setter) por ocasião do acesso a escrita

Quando tratamos de propriedades é importante entender as duas espécies de acesso

\definition{Acesso de leitura: acontece quando uma expressão de acesso a campo do lado direito é utilizada. Isso inclui chamadas no formato obj.field(), onde fiel é acessado para ser lido.}

\definition{Acesso de escrita: ocorre quando uma expressão de acesso a campo recebe atribuição de um valor no formato obj.field = value. Também pode ocorrer em combinação com um acesso de leitura em operadores especiais de atribuição como += em espressões como obj.fiel +=value.}

Acessos de leitura e escrita são diretamente refletidos na sintaxe, como no exemplo seguinte:

class Main{
    public var x(default, null): Int;
    static public function main()  { }
}

Em sua maior parte, a sintaxe é similar a sintaxe das variáveis, e as mesmas regras se aplicam. Propriedades são identificadas por:

  - a abertura de parenteses "(" depois do nome do campo,

  - seguido de um identificador de acesso especial (no caso:default),

  - com uma vírgula "," separadora

  - um outro  identificador de acesso especial (no caso: null)

  - antes do fechamento do parenteses ")".

Os identificadores de acesso definem o comportamenteo quando o campo é lido (pelo primeiro identificador) e alterado (segundo identificador). Os valores aceitos para os identificadores de acesso são:

default: permite acesso normal ao campo se ele for publicamente visível, senão é igual ao acesso com null.

null: Só permite acesso de dentro da classe em que está definido.

get/set: O acesso é gerado como uma chamada ao método de acesso. I compilador assegura que o método de acesso esteja disponível.

dynamic: Como set/get, mas não verifica a existência do método de acesso.

never: não permite acesso de nenhuma forma.


\definition{definition{Metodo de acesso: Um método de acesso (ou acessador) para um campo chamado field do tipo T é um getter nomeado de get_field do tipo Void->T ou um setter do tipo T->T.}

\trivia{Nomes de métodos de acesso}{No Haxe 2, nomes arbitrários de identificadores eram permitidos para os métodos de acesso. Isso tornou a implementação do Haxe bastante difícil em algumas partes. Em especial, Refelcet.getProperty() e Reflect.setProperty() precisavam assumir que qualquer nome pudesse ser usado, exigindo que os geradores dos targets precisassem criar meta-informação e fazer buscas.
Proibimos esses identificadores e escolhemos a convenção get_ e set_ que simplificou muito a implementação. Essa foi uma das mudanças que quebraram compatiblidade entre o Haxe 2 e 3.}

\subsection{Combinações de identificadores de métodos de acesso comuns}

O exemplo seguinte mostra as combinações comuns:

class Main {
  // leitura externa, escrita só dentro de Main
  public var ro(default, null):Int;
  
  // escrita externa, leitura só de dentro do Main
  public var wo(null, default):Int;
  // access through getter get_x and setter
  
  // acesso através dos métodos de acesso get_x e set_x
  public var x(get,set):Int;
  
  // acesso de leitura atraves de get_x, sem acesso de escrita
  public var x(get,never):Int;
  
  // exigido pelo campo x
  function get_x() return 1;
  function set_x(x) return x;
  
  // exigido pelo campo y
  function get_y return 1;
  
  function new()  {
      var v = x;
      x = 2;
      x += 1;
  }

   static function main() {
      new Main();
   }
}

 O Javascript gerado ajuda a entender como o acesso ao campo do método main é compilado:

var Main = function() {
  var v = this.get_x();
  this.set_x(2);
  var _g = this;
  _g.set_x(_g.get_x() + 1);
};

Como especificado, o acesso de leitura gera uma chamada a get_x(), enquanto o acesso a escrita gera uma chamada a set_x() onde 2 é o valor sendo atribuído a x. A forma com que += é gerado pode parecer um pouco esquisita inicialmente, mas pode ser facilmente justificada com o exemplo seguinte:

class Main {
    public var x(get, set):Int;
    function get_x() return 1;
    function set_x(x) return x;
    public function new() { }

    static public function main() {
        new Main().x += 1;
    }
}

O que acontece aqui é que a parte da expressão do campo de acesso a x no método main é complexa: Ela tem potenciais efeitos colaterais, como a construção do main nesse caso. Assim o compilador não pode gerar a operação += como new Main() = new Main().x + 1 e tem que guardar a expressão complexa em uma variável local:

Main.main = function() {
   var _g = new Main();
   _g.set_x(_g.get_x() + 1);
}


\subsection {Impacto no sistema de tipo}

A presença de propriedades tem diversas consequências no sistema de tipos. É de grande importância a compreensão de que propriedades são uma funcionalidade de compilação e dessa forma exigem que os tipos sejam conhecidos. Se atribuíssemos Dynamic a uma classes com propriedades, os acessos de campo não respeitariam os métodos de acesso. Da mesma forma, restrições não se aplicam mais e todos os acesso são virtualmente públicos.

Ao usar os identificadores de acesso get ou set, o compilador assegura que os métodos realmente existam. O seguinte código não compila:

class Main {
    // Método get_x exigido pela propriedade x está faltando
    public var (get,null):Int;
    static public function main() { }
}

O método get_x está faltando, mas ele não precisa ser declarado na classe que defune a propriedade, contanto que uma classe pai o defina:

class Base {
    public function get_x() return 1;
}

class Main extends Base {
    // ok, get_x is declared by parent class
    public var x(get, null):Int;
    
    static public function main() {}
}

O modificador de acesso dynamic funciona extamente como get ou set, mas não verifica a existência

\subsection{Regras para os métodos de acesso getter e setter}

A visibilidade do método de acesso  não tem afeito sobre a acessibilidade de sua propriedade. Isso é, se uma propriedade é pública e definida para ter um método getter, esse getter pode ser definido como private, sem levar isso em conta.

Tanto o getter quanto o setter podem acessar seu campo físico para armazenar dados. O compilador assegura que essa espécie de acesso a campos não passe para o método de acesso se feita de dentro do próprio método de acesso, evitando assim recursões infinitas:

class Main {
    public var x(default,set):Int;

    function set_x(newX) {
        return x = newX;
    }

    static function main () { }
}

Entretanto, o compilador assume que um campo físico existe apenas se um dos identificadores de acesso for default ou null.

\definition{Campo físico}{Um campo é considerado físico se ele é um dos seguintes:

  - uma variável
  - uma propriedade com acesso de leitura ou acesso de escrita sendo default ou nullo
  - uma propriedade com o metadado :isvar

Se esse não for o caso, o acesso do campo de dentro do método de acesso gera um erro de compilação:

class Main {
    // Esse método não pode ser acessado porque não
    // é uma variável real
    public var x (get,set) : Int;

    function get_x() {
        return x;
    }
    
    function set_x() {
        return this.x = x;
    }

    static public function main()  {  }
}


class Main {
    // @isVar força o campo a ser físico
    // permitindo que o programa compile
    @:isVar public var x(get, set):Int;

    function get_x() {
        return x;
    }

    function set_x(x) {
        return this.x = x;
    }

    static public function main() {}
}

}

\trivia{Tipo property setter}{Não é incomum para novos usuários do Haxe ser surpreendido pelo tipo de um método setter ser exigido como T->T ao invés do que parece mais natural T->Void. Afinal, porque um setter teria que retornar algo?

O racional é que nós ainda queremos ser capazes de usar o atribuição de campos utilizando setters como expressões do lado direito. Dada uma sequência como x = y = 1, ela é valorada como x = (y = 1). De forma a atribuir o resultado de y = 1 em x, ela precisa ter um valor. Se y tivesse um setter retornando void, isso não seria possível.}

\section{Métodos}

\subsection{Sobreescrevendo métodos}

\subsection{Efeitos de variações e modificadores de acesso}

Sobreinscrição adere as regras de variantes. Isso é, seus tipos de argumentos permitem contravariação(tipos menos específicos) enquanto seus tipos de retorno permitem covariação (tipos mais específicos):

class Base {
    public function new() { }
}

class Child extends Base {
    private function method(obj:Child):Child {
        return obj;
    }
}

class ChildChild extends Child {
    public override function
    method(obj:Base):ChildChild {
        return null;
    }
}
class Main {
    static public function main() { }
}

Intuitivamente isso segue o fato de que argumentos são "escritos na" finção e o valor de retorno e "lido da" função.

O exemplo também demonstra como a visibilidade (ver seção) pode ser alterada: um campo sobrescrito pode ser public se o campo sobrescrito é private, mas não o contrário.
Não é possível sobrescrever campos que são declarados como alinhados (inline, ver seção). Isso se deve aos conceitos conflitantes. Enquanto alinhamento é feito em tempo de compilação substituindo a chamada com o corpo da função, a sobreinscrição de campo necessariamente é resolvida em tempo de execução.

\subsection{Modificadores de acesso}

\subsection{Visibilidade}

Campos são privados por padrão, implicando que apenas a classe e as subclasses podem acessá-los. Eles podem ser tornados publicos com a utilização de um modificador de acesso, permitindo que sejam acessados de qualquer lugar.

Exemplo


A omissão do modificador de visibilidade normalmente padroniza a visibilidade para private, mas há exceções onde isso se torna público ao invés disso:

1. Se a classe é declarada como externa

2. Se o campo é declarado em uma interface

3. Se o campo sobrescreve um campo public

\Trivia{Protected}{Em Haxe não há a palavra-chave protected, conhecida em Java e C++ e outras linguagens orientadas a objeto. Entretanto, o comportamento privat é igual ao comportamento protected dessas linguagens. O que falta no Haxe na verdade é o comportamento realmente privado como nas linguagens mencionadas}

\subsection{Alinhamento (inline)}

A palavra-chave inline permite que o corpo das funções seja diretamente inserido no local de suas chamadas. Isso pode ser um ferramenta poderosa de otimização, mas deve ser usado ajuizadamente, uma vez que nem todas funções são boas candidatas para o comportamento alinhado. O exemplo seguinte demonstra seu uso básico:

class Main {
    static inline function mid(s1:Int, s2:Int) {
        return (s1 + s2) / 2;
    }
    
    static public function main() {
       var a = 1;
       var b = 2;
       var c = mid(a, b);
    }   
}

O resultado em Javascript revela o efeito de inline:

(function () { "use strict";
var Main = function() { }
Main.main = function() {
    var a = 1;
    var b = 2;
    var c = (a + b) / 2;
}
Main.main();
})();

Como fica evidente, o corpo da função (s1+s2)/2 do campo mid foi gerado no local da chamada mid(a,b), substituindo s1 por a e s2 por b. Isso evita que uma chamada de função, que, dependendo do target e da frequência com que ocorre, cause notáveis problemas de desempenho.

Não é fácil julgar se uma função se qualifica para se alinhada. Funções curtas que não tenha expressões (como a = atribuição) são normalmente bons candidatos, mas mesmo funções mais complexas podem ser candidatas. Entretanto, alguns casos de alinhamento podem, na realidade, causar detrimento de desempenho; por exemplo, porque o compilador tem que criar variáveis temporárias para expressões complexas.
O alinhamento não é garantidamente feito. O compilador pode cancelar o alinhamento por varias razões ou o usuário pode oferecer o comando --no-inline para desativar o alinhamento. A única exceção é se a classe é externa (ver seção) ou se o campo de classe tem o metadado :extern (ver seção), caso em que o inline é forçado. Se ele não puder ser feito, o compilador envia um erro.

É importante se lembrar disso quando se apoia em alinhamentos:

class Main {
    public static function main () { }
    static function test() {
        if (Math.random() > 0.5) {
            return "ok";
       } else {
           error("random failed");
       }
    }

    static inline function error(s:String) {
        throw s;
    }
}

Se a chamada a error é alinhada, o programa compila corretamente porque o verificador de controle de fluxo é satisfeito devido a expresão throw (ver seção) alinhada. Se o inline não for feito, o compilador só verá uma chamada de função a error e gera a seguinte mensagem de erro A return is missing here.

\subsection{Dynamic}

Métodos podem ser descritos como a palavra-chave dynamid para torná-los (re-)associáveis:

class Main {
    static dynamic function test() {
        return "original";
    }   

    static public function main() {
         trace(test()); // original
         test = function() { return "new"; }
         trace(test()); // new
    } 
}

A primeira chamada a test retorna o String "original". Na linha seguinte uma nova função é atribuída a tes. Isso é exatamente o que dynamic tem intenção de permitir. Campos funções podem receber novas funçoes como atribuições. Como resultado, a próxima chamada a test() retorna o String "new"

Campos dinâmicos não podem ser alinhados por razões óbvias: Enquanto o alinhamento ocorre em tempo de compilação, funções dinâmicas são resolvidas em tempo de execução.

\subsection{Sobreinscrição(Override)

O modificador de acesso override é exigido quando um campo que também existe em uma classe pai (ver seção) é declarado. O seu propósito e assegurar que o autor da classe está ciente que está sobrescrevendo; o que não é sempre óbvio especialmente em hierarquias extensas de classes. Da mesma forma, a inclusão de override em um campo que não está sobrescrevendo nada (por exemplo, devido a um erro de nomenclatura) dispara um erro.

Os efeitos da sobrescrição de campos são detalhados em Sobrescrição de Métodos(ver seção). Esse modificador só é permitido sobre campos método.

\chapter{Expressões}

Expresões em Haxe definem o que um programa faz. A maior parte das expressões se encontram no corpo de um método (ver seção), aonde elas são combinadas para expressar o que aquele método deve fazer. Essa seção explica as diferentes espécies de expressões. Algumas definições ajudam aqui:

\definition {Nome}{Um nome geral pode ser referir a:

  - um tipo,

  - uma variável local

  - uma função local

  - um campo.}

\definition{Identificador}{Os identificadores do Haxe começam com uma marca de sublinado _, um cifrão $, um caractere minuscúlo a-z ou um caractere maiúsculo A-Z. Depois disso, qualquer combinação e número de _,A-Z,a-z e 0-9 pode se seguir.

Maiores limitações são derivadas do contexto de uso, que são verificadas durante a tipagem:

  - Nomes de tipos devem começar com letra maiúscila A-Z ou marca de sublinhado _.

  - Cifrões iniciais não são permitidos para qualquer espécie de nome (nomes com cifrão são em sua maioria usados para consolidação de macros (ver seção)}

\section{Blocos}

Um bloco em Haxe começa com a abertura de chaves { e termina com o seu fechamento }. Um bloco pode conter diversas expressões, cada uma seguida por um ponto-e-vírgula ;. A sintaxe geral é assim:

{
    expr1;
    expr2;
    ...
    exprN;
}

O valor, e por extensão o tipo, de um bloco de expressão é igual ao valor (e o tipo) da última subexpressão.

Blocos podem conter variáveis locais declaradas pela expressão var (ver seção), bemo como funções locais declaradas por expressões function (ver seção). Essas estarão disponíveis dentro do bloco e dentro dos sub-blocos. Também só se encontram disponíveis depois de sua declaração. O exemplo seguinte usa var, mas as mesmas regras se aplicam à funções:

{
    a; // erro, a não foi ainda declarada
    var a = 1; // declara a
    a; // ok, a já foi declarado
    {
        a; // ok, a está disponível nos sub-blocos
    }
    a; // ok, a ainda está disponível após o sub-bloco
}
a; // erro, a não está disponível fora do bloco

Em tempo de execução, blocos são valorados de cima para baixo. O controle de fluxo (por exemplo, exceções (ver seção) ou expressões de retorno) podem abandonar o bloco antes que todas as expressões sejam valoradas.

\section{Constantes}

Haxe suporta as seguintes constantes:

Int: Um inteiro (ver seção) como 0, 1, 89797,-12, 0xFF0000.
Float: Um número de ponto flutuante (ver seção) como 0.0, 1., .2, -93.2 .
String: Uma sequência de caracteres (ver seção), como "", "foo", '', 'bar' .
true,false: Um valor booleano (ver seção).
null: O valor nulo.

Além disso, a estrutura de sintaxe interna trata identificadores como constantes, o que pode ser relevante quando se trabalha com macros.

\section{Operadores Binários}

\section{Operadores Unários}

\section{Declaração de Arrays}
Arrays são inicializados com valores entre colchetes separados por ,. [] representa um array vazio, e [1, 2, 3] inicializa um array com os três elementos 1, 2 e 3.

O código gerado pode ser menos conciso em algumas plataformas que não suportam a inicialização de arrays. Basicamente, o código da inicialização pode parecer com o seguinte:

var a = new Array();
a.push(1);
a.push(2);
a.push(3);

Isso deve ser mantido em mente quando se toma a decisçao de alinhar uma função (ver seção) uma vez que mais código alinhado será visível do que a sintaxe do Haxe mostra.

Técnicas avançadas de inicialização são descritas na seção Compreensão de Arrays (ver seção)

\section{Declaração de objetos}

A declaração de objetos começa com uma chave de abertura {, após o que pares chave:valor separados por vírgula se sucedem até a chave de fechamento}

{
   chave1:valor1,
   chave2:valor2,
   ...
   chaveN:valorN
}

Mais detalhes sobre a declaração de objetos são dados da seção de estruturas anônimas (ver seção)

\section{Acesso a campos}

O acesso a campos é expressado usando o ponto. seguido pelo nome do campo.

objeto.nomedocampo

Essa sintaxe também é usada para acessar tipos dentro de pacotes na forma pacote.Tipo.

O tipificador assegura que o campo acessado exista de fato e pode aplicar transfromações, dependendo da natureza do campo. Se o acesso a um campo é ambíguo, o entendimento da ordem de resolução (ver seção) pode ajudar

\section{Acesso a arrays}

O acesso a arrays pe expresso pela utilização de uma expressão entre colchetes; a expressão índica o índice.

expr[exprDoIndice]

Essa notação é permitida com expressões arbitrárias, mas em nível de tipagem, apenas certas combinações são permitidas:

  - expr é do tipo Array ou Dynamic e exprDoIndice é do tipo Int

  - expr é um tipo abstrato (ver seção) que define um acesso a array correspondente.

\section{Chamada a funções}

Chamadas a funções consistem em expressões arbitrárias de itens, seguida pela lista de expressões que servem de argumentos, separadas por vírgulas dentro de parenteses:

item(); // chamada sem argumentos
item(e1); // chamada com um argumento
item(e1, e2); // chamada com dois argumentos
item(e1, e2, ..., eN); chamada com muitos argumentos

\section{var}

A palavra-chave var permite a declaração de múliplas variáveis separadas por vírgula , . Cada variável deve ter um identificador válido e opcionalmente uma atribuição de valor na sequência com o operador =. Variáveis também podem ter um indicador explícito de tipo.

var a; // declara a variável local a
var b:Int; // declara a variável b do tipo Int
var c = 1; // declara a variável c, inicializada para o valor 1
var d,f = 2; // delara as variáveis d e f inicilaizadas par o valor 2 

O comportamento de escopo de variáveis locais é descrito em blocos(ver seção)

\section{Funções locais}

Haxe suporta funções de primeira-classe e permite a declaração de funções locais em expressões. A sintaxe é igual a dos métodos campos de classe (ver seção):

class Main {
    static public function main() {
        var value = 1;
        function myLocalFunction(i) {
            return value + i;
        }
        trace(myLocalFunction(2)); // 3 
    }
}

Nós declaramos myLocalFunction dentro do bloco de expressão (ver seção) do campo de classe main. Ela toma um argumento i e o adiciona a valie, que é definido fora de seu escopo.

O escopo é equivalente ao de variáveis (ver seção) e na maioroa das vezes, escrever uma função local com nome pode ser considerado equivalente a atribuição de  uma função local sem nome a uma variável local.

var myLocalFunction = function(a) { }

Entretanto, há algumas diferençãs relacionadas a parâmetros de tipo e a posição da função. Falamos em função "lvalue" (l por left = esquerda) se não for atribuída a nada no momento de sua declaração e em uma função "rvalue" (r por right = direita) caso contrário.

  - Funções lvalue exigem um nome e podem ter parâmetros de tipo (ver seção)

  - Funções rvalue podem ter um nome, mas não podem ter parâmetros de tipo.

\section{new}

A palavra-chave new sinaliza que uma classe (ver seção) ou um tipo abstrato(ver seção) está sendo instanciado. É seguido pelo caminho (ver seção) do tipo que está a ser instanciado. Também pode listar parâmetros de tipo (ver seção) cercados por <> e separados por vírgulas , . Depois seguem entre parênteses os argumentos para o constructor, também separadaos  por vírgula, .

class Main<T> {
    static public function main() {
        new Main<Int>(12, "foo");
    }

    function new(t:T, s:String) { }
}

Dentro do método main, nós instanciamos uma instância da própria classe Main, com  parâmetro de tipo explícito entre <> e os argumentos para geração seguindo entre parenteses: (12 e "foo"). Como podemos ver, a sintaxe é similar a sintaxe de chamada de funções (ver seção); é normal falarmos em "chamadas a constructors".

\section{for}

O Haxe não suporta loops de for tradicionais de C. Em Haxe a palavra-chave for deve ser seguida pela abertura de parenteses (, um identificador de variável seguido da palavra chave in e uma expressão arbitrária usada como uma coleção para iteração. Ao fechamento dos parênteses deve seguir um corpo de expressões.

for (v in e1) e2;

O tipificador assegura que o tipo de e1 seja algo que possa ser iterado, o que é tipicament o caso em que ele tenha um método iterator que retorne um Iterator<T>, ou que seja ele mesmo um Iterator<T>.

A variável v é então disponível dentro do corpo do loop e2 e detém o valor de cada elemento individual da coleção e1.

O tipo de uma expressão for pe sempre Void, implicando que ela não tem valor e não pode ser usada do lado direito de uma expressão.

O controle de fluxo de loops pode ser afetado pelas expressões break (ver seção) e continue (ver seção).

\section{while}

Um loop while normal começa com essa palavra chave, é seguido de uma expressão de condição entre parênteses e do corpo do loop.

while (condição) expressão;

A condição deve ser do tipo Booç

A cada iteração, a condição é valorada, se for falsa, o loop é interrompido, senão as expressões no corpo do loop são processadas.

class Main {
    static public function main() {
        var f = 0.0;
        while (f < 0.5) {
             trace(f);
             f = Math.random();
        }
    }
}

Esse tipo de loop não garante que as expressões do corpo sejam processadas: Se a condição não se mantiver de início o corpo nunca é valorado. Isso é diferente de loops do-while (ver seção)

\section{do-while}

Um loop do while começã com a palavra-chave do, seguida pelo corpo de expreessão a ser processado, seguido pela palavra-chave while, seguida pela expressão de condição entre parenteses:

do expressão while (exprDeCondição);

A expressão de condição deve ser do tipo Bool.
Como a sintaxe sugere, o corpo de expressão é sempre processado, pelo menos uma vez, diferente do que acontece com loops while (ver seção).

\section{if}

Expressões condicionais vem em com a palavra-chave if antecedendo-as. A condição a ser avaliada aparece entre parênteses e uma expressão para ser valorada caso a condição se sustente segue.

if(condição) expressão;

A condição tem que ser do tipo Bool.
Opcionalmente a expressão pode ser seguida pela palavra-chave else e também uma nova expressão para ser avaliada caso a condição não se sustente.

if(condição) expressãoSeVerdadeiro else expressãoSeFalso;

A expressão se falso pode ser uma nova expressão if

if(condição1) expressão1
else if(condição2) expressão2
else expressão3;

Se o valor de uma expressão if é exigida, por exemplo, em var x = if(condição1) expressão1 else expressão2, o tipificador assegura que os tipos das expressões1 e expressão2 sejam unificáveis. Se não houver expressão else, o tipo inferido é Void.

\section{switch}
\section{try/catch}
\section{return}
\section{break}
\section{continue}
\section{throw}

\section{cast}

O Haxe permite dois tipos de casts (fusões)

cast expr; // unsafe cast (fusão insegura)
cast (expr, Type); // safe cast (fusão segura)

\subsection{unsafe cast}

Fusões inseguras são úteis para subverter o sistema de tipos. O compilador tipifica expr normalmente e então a envelopa em um monomorfo (ver seção). Isso permite que a expressão seja atribuída a qualquer coisa. Fusões inseguras não criam nenhum tipo dinâmico, como o exemplo a seguir mostra:

class Main {
    public static function main() {
        var i = 1;
        $type(i); // Int
        var s = cast i;
        $type(s); // Unknown <0>
        Std.parseInt(s);
        $type(s); // String
    }
}

A variável i é tipada como Int e então atribuída a variável s usando o unsafe cast cast i. Isso faz com que s seja de um tipo desconhecido, um monomorfo. Seguindo as regras normais de unificação (ver seção) ela pode ser amarrada a qualquer tipo, como String, nesse exemplo.

Essas fusões são chamadas de "unsafe casts" porque o comportamento em tempo de execução para casts inválidos não são definidos. Enquanto a maioria dos targets dinâmicos são prováveis de funcionar, isso pode levar a erros indefinidos em targets estáticos (ver seção).

Unsafe casts tem entre muito pouco e nenhum sobregasto em tempo de execução.

\subsection {safe cast}

De forma diferente das fusões inseguras (ver seção), o comportamento em tempo de execução no caso de uma falha de fusão é definido para fusões seguras:

class Base {
    public function new() { }
}

class Child1 extends Base { }

class Child2 extends Base { }

class Main {
    public static function main() {
        var child1:Base = new Child1();
        var child2:Base = new Child2();
        cast (child1, Base);
        cast (child1,Child2); //Exceção: Erro de cast de classe
    }
}

Nesse exemplo nós primeiros fundimos uma instância da de classe do tipo Child1 par Base. Nós então temtamos fundir a mesma instância de classe para Child2, o que não é permitido porque instâncias de Child2 não são instâncias de Child1.

O compilador de Haxe garante que uma selçao do tipo String  seja lançada (ver seção) nesse caso. Essa exceção pode ser apanhada usando um bloco try/catch (ver seção).

Safe casts podem ter sobregasto em tempo de execução. É importante entender que o compilador já gera verificações de tipo, então é redundante adicionar verificações manuais como, por exemplo, usar Std.is. A intenção do uso pe tentar a fusão segura e pegar exceção de String.

\section {Verificação de tipo}

Desde Haxe 3.1.0

É possível empregar verificações em tempo de compilação usando a seguinte sintaxe:

(expr:type)

Os parênteses são obrigatórios. Diferente das fusões seguras (ver seção) esse constructo não tem nenum impacto em tempo de execução. Ele tem duas implicações em tempo de compilação:

1. Inferência de cima para baixo (ver seção) é utilizada para tipar a expressão com o tipo type.

2. A expressão tipada resultante  é unificada (ver seção) com o tipo type.

Isso tem o efeito normal de ambas as operações tais quais os tipos sendo utilizados como os tipos esperados quando executando a resolução de identificadores não qualificados (ver subseção) e a verificação de unificação para casts de classes abstratas (ver subseção).

\chapter{Funcionalidades da Linguagem}

\section{Compilação Condicional}

O Haxe permite compilação condicional com o uso de #if, #elseif e #else e com a verificação de sinalizadores de compilação (compiler flags).

\definition{Sinalizador de compilação){Um sinalizador de compilação é um valor configurável que pode influênciar o processo de compilação. Tais sinalizadores podem ser definidos pela chamada através da linha de comando com -D chave=valor oi apenas -D chave, caso em que o valor assume valor-padrão "1". O compilador também define diversos sinalizadores internamente para passar informação entre diferentes passos de compilação.

O exemplo seguinte mostra um exemplo de uso de compilação condicional

(N do T: Exemplo de chamada do compilador haxe ... -D debug debug_level=2)

class ConditionalCompilation {
    public static function main(){
    #if !debug
       trace("ok");
    #elseif (debug_level > 3)
        trace(3);
    #else
        trace("debug level too low");
    #end
    } 
}

Compilando sem sinalizadores de compilação, isso deixaria apenas o trace("ok"); no corpo do método main. Os outros ramos são descartados durante o processamento do arquivo. Ainda assim, esses ramos devem conter sintaxe válida, mas o código não é verificado quanto a tipos. As condições depois de #if e #elseif permitem as seguintes expressões:

  - Qualquer identificador é substituíso pelo valor do sinalizador de compilação com o mesmo nome. Observe que -D sinal-um da linha de comando cria tanto os sinalizador sinal_um quanto o sinalizador sinal-um.

  - Os valores das constantes dos tipos String, Int e Float são usados diretamente.

  - Os operadores booleanos && (e), || (or) e !(não) funcionam como esperado.

  - Os operadores ==, !=, >, >=, <, <= podem ser usados para comparar valores.

  - Parenteses ( ) podem ser usados para agrupar expressões como de costume.

Uma lista exaustiva de todas as definições internas pode ser obtida com a chamada do Compilador do Haxe com o argumento --help-defines. O compilador permite múltiplos sinalizadores -D por compilação.

\section{Externalização}

Externs pode ser usado para descrever interações específicas a targets de uma maneira segura para tipos. Eles são definidos como classes normais, exceto que:

  - a palavra-chave class é precedida pela palavra-chave extern.

  - métodos (ver seção) não tem expressões e

  - todos os tipos dos argumentos e do retorno são explícitos.

Um exemplo normal da Biblioteca padrão (ver capítulo) é a classe Math, como o seguinte extrato mostra:

extern class Math
{
    static var PI(default, null) : Float;
    static function floor(v:Float) : Int;
}

Vemos que a externalização pode definir tanto  métodos quanto variáveis (na verdade, PI é declarado como uma propriedade somente-leitura). Uma vez que essa informação está disponível para o compilador, ela permite acessos de campo concordantes e também a identificação dos tipos:

class Main {
    static public function main() {
    var pi = Math.floor(Math.PI);
    $type(pi); // Int
    }
}
 
Isso funciona porque o tipo do retorno do método floor é declarado como Int. 

A biblioteca padrão do Haxe vem com muitas externalizações para os targets Javascript e Flash. Elas permitem o acesso a APIs nativas de uma maneira segura em relação aos tipos e são ferramentas úteis para a concepção de APIs de alto-nível. Também há externalizações para muitas bibliotecas populares na haxelib (ver capítulo);

Os targets Java, Flash e C# permitem a inclusão direta de bibliotecas nativas a partir da linha de comando (ver capítulo). Detalhes específicos são explicados nas respectivas seções de Detalhes de Target (ver capítulo).

Alguns targets como Python e Javascript podem exigir "import" de código adicional que carrega uma classe extern de um módulo nativo. O Haxe oferce maneiras de declarar essas dependências também descritas nas seções respectivas de Detalhes de Target (ver capítulo).

\section{Extensões estáticas}

\definição{Extensão estática}{Uma extensão estática permite uma pseudo-extensão dos tipos existentes sem modificar sua fonte. No Haxe isso é conseguido através da declaração de um método estático com um primeiro argumento do tipo que se pretende estender e então trazendo a definição da classe (a ser estendida) para o contexto através de using.

Extensões estáticas podem ser uma ferramenta poderosa que permite aumentar os tipos sem verdadeiramente mudá-los. O exemplo seguinte demonstra o uso:

using Main.IntExtender;

class IntExtender {
    static public function triplo(i:Int) {
        return i * 3;
    }
}


class Main {
    static public function main() {
        trace(12.triplo());
    }
}

Claramente, Int não oferece um método chamado triplo, ainda assim esse programa compila e dá o resultado 36, como esperado. Isso porque a chamada para 12.triplo() é transformada em IntExtender.triplo(12). Existem três requerimentos para isso:

1. Tanto o literal 12 e o primeiro argumento de triplo são do tipo Int.

2. A classe IntExtender é trazida para o contexto através de using Main.IntExtender (N. do T.: Não está claro se poderíamos ter chamado a classe do nome que queiramos, parece que sim... faça o teste)

3. Int não tem um campo triplo por si só (se tivesse, esse campo tomaria a prioridade sobre a extensão estática).

Extensões estáticas são geralmente considerados adoçantes sintáticos (sintax sugar) e de fato são, vale apena observar que elas podem ter um efeito dramático na legibilidade do código: Ao invés de chamadas no formato f1(f2(f3(f4(x)))), o encadeamento de chamada na forma x.f4().f3().f2().f1() pode ser usado.

Seguindo as regras previamente descritas em Ordem de Resolução (ver seção), múltiplas expressões using são verificadas de cima para baixo, com os tipos de cada módulo, bem como com os campos de cada tipo sendo verificados de cima para baixo. A utilização de um módulo (em oposição a um tipo específico de um módulo, ver Módulos e Caminhos (ver seção)) como uma extensão estática traz todos os seus tipos ao contexto.

\subsection{Na Biblioteca Padrão do Haxe}

Diversas classes na Biblioteca Padrão do Haxe são adequadas para o uso de extensões estáticas. O próximo exemplo mostra o uso de StringTools:

using StringTools;
    
class Main {
    static public function main() {
        "adc".replace("d", "b");
    }
}

Ainda que String não tenha uma funcionalidade replace por si próprio, o uso da extensão estática StringTools fornece um. Como normalmente, o resultado de Javascript esclarece a transformação:

Main.main = function() {
    StringTools.replace("adc","d","b");
}

As seguintes classes da Biblioteca parrão  foram concebidas para ser usadas como extensões estáticas:

StringTools: Fornece funcionalidades estendidas sobre os strings, como substituição ou eliminação de espaços.

Lambda: Fornece métodos funcionais para iteráveis.

haxe.EnumTools: Fornece funcionalidades sobre a informação de tipos em enums e suas instâncias.

haxe.macro.Tools: Fornece diferentes  extensões para trabalhar com macros (ver Ferramentas (seção)).

\trivia{using "using"}{Como a palavra "using" foi adicionada a linguagem, se tornou comum em inglês aparecerem problemas na utilização da expresão usando using (using using), razão pela qual o autor do manual optou por chamar a funcionalidade por sua definição formal: Extensão Estática}

\section{Correspondência de padrões (Pattern Matching)}

\subsection{Introdução}

Pattern matching é o processo de ramificação dependendo da correspodência de um dado valor a padrões, possivelmente complicados. No Haxe, toda correspondência de padrões é feita dentro de uma expressão switch (ver seção) onde as expressões case individuais representam os padrões. Aqui exploraremos a sintaxe de diferentes padrões usando essa estrutura de dados como o exemplo corrente:

enum Tree<T> {
    Leaf(v:T);
    Node(l:Tree<T>, r:Tree<T>);
}

(N do T: Tree = árvore, Leaf = folha, Node = Nó; l por left:esquerda, r por right:direita)

O básico da correspondência de padrões inclui:

  - Padrões sempre serão correspondidos de cima para baixo.

  -  O mais alto dos padrões que casar com o valor de entrada terá sua expressão executada.

  - Um padrão _ corresponde com qualquer coisa, então case _: é igual a default:

\section{Correspondência de Enum}

Enums podem ser correspondidos por seus constructors de uma maneira natural:

var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
// myTree é um nó (uma possibilidade para árvore)
// (nós contém duas árvores)
// a árvore esquerda é uma folha (v="foo")
// a árvore direita é um nó (que contém duas árvores):
//   a árvore esquerda (da árvore direita) é uma folha (v="bar")
//   e árvore direita (da árvore direita) também é uma folha (v="foobar")

var match = switch(myTree) {
    case Leaf(_): "0"; // corresponde a qualquer nó 
                       //que seja apenas uma folha
    case Node(_, Leaf(_)): "1"  // corresponde a qualquer nó
                                //que tenha uma folha na direita
    case Node(_, Node(Leaf("bar"), _)): "2"; // corresponde
                               // a qualquer nó que tenha um nó na direita
                               // onde a árvore esquerda seja uma folha com                               // v="bar"
    case _: "3"; // corresponde a qualquer coisa
}
trace(match); // 2

A correspondência de nós será feita de cima para baixo e escolherá a primeira alternativa em que houver o casamento. A interpretação passo a passo ajuda a entender o processo:

case Leaf(_): correspondência não bate, porque myTree é um nó

case Node(_,Leaf(_)): falha porque a sub-árvore a direita não é uma folha

case Node(_, Node(Leaf("bar"),_)); correspondência corresponde.

case _: não chega a ser testada, porque a anterior já resolveu.


\subsection{Captura de  variável} 

É possível achar qualquer vaolor de um sub-padrão achando sua correpondência com um identificador:

var myTree = Node(Leaf("foo"),Node(Leaf("bar"), Leaf("foobar")));
var name = switch(myTree) {
    case Leaf(s): s;
    case Node(Leaf(s), _): s;
    case _: "nenhum";
}
trace(name); // foo

Isso retornaria algum dentre os seguintes:

  - Se myTree é uma única folha, o nome da folha é retornado

  - Se myTree é um nó cuja subárvore esquerda é uma folha, o nome da folha da subárvore da esquerda é retornado (o caso do exemplo retornando "foo").

  - Em outros casos "nenhum" é retornado.

Também é possível usar = para capturar valores que são correspondentes a um padrão:

var node = switch(myTree) {
    case Node(leafNode = Leaf("foo"), _):leafNode;
    case x: x;
}
trace(node); // Leaf(foo)

Aqui, leafNode é associado a Leaf("foo") se o dado de entrada corresponder a isso. Em todos os outros casos, a própria myTree é retornada: case x funciona de forma similar a case _ achando correspondência com qualquer coisa, mas colocando um identificador com um nome como x, o valor de x (qualquer que seja) vai ser associado a (var) node.

\section{Correspondência de Estrutura}

Também é possível achar a correspondência contra padrões de campos de estruturas anônimas e instâncias:

var myStructure = {
    name: "haxe",
    rating: "awesome"
};
var value = switch(myStructure) {
    case { name: "haxe", rating: "poor" }: throw false;
    case { rating: "awesome", name: n }:n;
    case _: "no awesome language found";
}
trace(value); // haxe

No segundo caso nós associamos o campo name ao identificador n, caso rating corresponda a "awesome". É claro que essa estrutura poderia ser colocada no formato Tree do exemplo anterior para combinar a correspondência entre estrutura e enum.

Uma limitação em relação a instâncias de classe é que você não pode achar a correspondêncoa com campos ou sua classe pai.

\subsection{Correspondência de array}

Arrays com tamanho fixo  podem ser correspondidos:

var myArray = [1, 6];
var match = switch(myArray) {
    case [2, _]: "0";
    case [_, 6]: "1";
    case []: "2";
    case [_, _, _]: "3";
    case _: "4";
}
trace(match); // 1

Isso imprimirá 1 porque array[1] corresponde a 6 e array[0] pode ser qualquer coisa.

\subsection{Padrões ou}

O operador | pode ser usado em qualquer lugar dentro dos padrões para descrever múltiplos termos aceitáveis:

var match = switch(7) {
   case 4|1: "0";
   case 6|7: "1";
   case 2: "2";
}
trace match; // 1

Se há uma variável capturada em um padrão ou, ela deve aparecer nos dois subpadrões.

\subsection{Guardas}

Também é possível restringir ainda mais os padrões com a sintaxe case;;; if(condition):

var myArray = [7, 6];
var s = switch(myArray) {
    case [a, b] if (b > a): b + ">" +a;
    case [a, b]: b + "<=" +a;
    case _: "found something else";
}
trace(s); // 6<=7

O primeiro case tem uma condição adicional de guarda if(b>a). Esse caso só será selecionado se a condição for verdadeira, senão a busca por correspondência continua com o próximo case.

\subsection{Correspondência sobre múltiplos valores}

A sintaxe de array pode ser usada para fazer a correspondência sobre múltiplos valores:

var s = switch [1, false, "foo"] {
    case [1, false, "bar"]: "0";
    case [_, true, _]: "1";
    case [_, false, _]: "2";
}
trace(s); // 2

Isso é bastante similar à correspondência normal de arrays, mas há algumas diferenças:

  - O número de elementos é fixo, então padrões de diferentes tamanhos de array não serão aceitos.

  - Não é possível capturar o valor do switch em uma variável, i.e. case x não é permitido aqui (case _ ainda é).

\subsection{Extratores}

Desde Haxe 3.1.0

Extratores permitem a aplicação de transformações aos valores a serem correspondidos. Isso é frequentemente útil quando uma pequena operação é exigida em um valor correspondido antes que o processo de correspondência prossiga:

enum Test {
   TString(s:String);
   TInt(i:Int);
}

class Main {
     static public function main() {
          var e = TString("fOo");
          switch(e) {
              case TString(temp):
              switch(temp.toLowerCase()) {
                   case "foo": true;
                   case _: false;
              }    
              case _: false;
          }
     }
}

Aqui nós temos que capturar o valor do constructor do enum TString em uma variável tem e usar um switch aninhado sobre temp.toLowerCase() (toLowerCase=paraMinúscula). Obviamente, queremos que a correspondência tenha sucesso se TString tiver o valor "foo" sem consideração ao uso de maiúsculas ou minúsculas. Isso pode ser simplificado com extratores:
(N. do T.: temp é o caso de x, sempre será verdadeiro, verificar...)

enum Test {
    TString(s:String);
    TInt(i:Int);
}
class Main {
    static public function main() {
    var e = TString("fOo");
    var success = switch(e) {
        case TString(_.toLowerCase() => "foo"): true;
        case _: false;
        }  
    }
}

Extratores são identidficados pela expresãoExtratora => expressão a corresponder. O compilador gerá código que é similar ao exemplo anterior, mas a sintaxe original foi bastante simplificada. Extratores consistem de duas partes, que são separadas pelo operador =>:

1. O lado esquerdo pode ser qualquer expressão, onde todas as ocorrências de _ são substituídas pelo valor que atualmente detém a correspondência.

2. O lado direito é um padrão que é comparado contra o resultado da valoração do lado esquerdo.

Uma vez que o lado direito é um padrão, ele pode conter um outro extrator. O exemplo seguinte encadeia dois extratores:

class Main {
    static public function main() {
        switch(3) {
            case add(_, 1) => mul(_, 3) => a: trace(a);
        }
    }
    static function add(i1:Int, i2:Int) {
        return i1 + i2;
    }

    static function mul(i1:Int, i2:Int) {
        return i1 * i2;
    }
}

Isso imprime 12 como o resultado da chamada a add(3, 1) onde 3 é o valor que correspondeu, e mul (4, 3) onde 4 é o resultado da chammada a add. Vale a pena observar que a do lado direito do segundo operador => é uma variável capturada (ver seção)

Atualmente não é possível usar extratores dentro de padrões or:

class Main {
    static public function main() {
        switch("foo") {
            // Extractors in or patterns are not allowed
            case (_.toLowerCase() => "foo") | "bar":
        }
    }
}

Entretanto, é possível ter padrões ou do lado direito de um extrator. então o exemplo anterior compilaria sem os parenteses.

\subsection{Verificações de exaustividade}

O compilador assegura que nenhum caso possível seja esquecido:

switch(true) {
    case false:
} // Verdadeiro não verificado

O tipo correspondente admite dois valores true e false, mas apenas falso é verificado.

\subsection{Verificações de padrão inúteis}

De forma similar, o compilador detecta padrões que nunca corresponderão ao valor de entrada:

switch(Leaf("foo")) {
    case Leaf(_) 
    | Leaf("foo"): // Esse padrão não é usado
    case Node(l,r):
    case _: // Esse padrão não é usado
}

\section {Interpolação de strings}

Com o Haxe 3 não é mai necessário concatenar partes de um string devido a introdução da interpolação de strings. Identificadores especiais, denotados pelo cifrão $ dentro de um string que utilize aspas simples ', são processados como se fossem identificadores concatenados

var x = 12;
trace(’O valor de x é $x’);n // O valor de x é 12

Além disso é possível incluir expressões inteiras em um string utilizando ${expr}, onde expr é qualquer expressão válida do Haxe.

var x = 12;
trace(’A soma de $x e 3 é ${x + 3}’);
// A soma de 12 e 3 é 15

A interpolação de strings é uma funcionalidade de compilação e não tem qualquer impacto em tempo de execução. O exemplo acima é equivalente a concatenação manual, que é exatamente o que o compilador gera:


Claro que o uso de strings com aspas simples sem qualquer interpolação permanece válido, mas cudiado deve ser tomado em relação ao caractere $, uma vez que ele dispara a interpolação. Se um cifrão de fato desejar ser utilizado no string, $$ pode ser usado.

trace("A soma de " + x + " e 3 é " + (x + 3));

\trivia{Interpolação de strings antes do Haxe 3}{A interpolação de strings é uma funcionalidade desde a versão 2.09. Naquele momento, a macro Std.format tinha de ser usada, sendo tanto mais lenta quanto menos confortável que a nova sintaxe de interpolação de strings}

\subsection{Preenchimento de arrays}

O preenchimento de arrays em Haxe usa a sintaxe existente para permitir a inicialização concisa de arrays. Éla é identificada pelos constructs for ou while

class Main {
    static public function main() {
        var a = [for (i in 0...10) i];
        trace(a); // [0,1,2,3,4,5,6,7,8,9]
        var i = 0;
        var b = [while(i < 10) i++];
        trace(b); // [0,1,2,3,4,5,6,7,8,9]
    }
}

A variável a é inicializada para um array contendo os números de 0 a 9. O compilador gera código que adiciona o valor de cada iteração do loop no array, o que é equivalente ao seguinte código:

var a = [];
for (i in 0...10) a.push(i);

A variável b é inicializada para um array com os mesmo valores, mas atráves de um estilo diferente de compressão usando while ao invés de for. Novamente, o código seguinte seria equivalente

var i = 0;
var a = [];
while (i<10) a.push(i++);

A expressão do laço pode ser qualquer uma, incluindo condições e laços aninhados, então o seguinte funciona como esperado:

class AdvArrayComprehension {
    static public function main() {
        var a = [
            for (a in 1...11)
                for(b in 2...4)
                    if (a % b == 0) 
                         a+ "/" +b
        ];
        trace(a); // [2/2,3/3,4/2,6/2,6/3,8/2,9/3,10/2]
    }    
}  

\section{Iteradores}

Com o Haxe, é muito fácil definir iteradores personalizados e tipos de datas iteráveis. Esses conceitos são representados pelos tipos Iterator<T> e Iterable<T> respectivamente:

typedef Iterator<T> = {
    function hasNext() : Bool;
    function next() : T;
}
typedef Iterable<T> = {
    function iterator() : Iterator<T>;
}

Qualquer classe (ver seção) que unifique (ver seção) estruturalmente com umdesses tipos pode ser iterada usando um laço for (ver seção). Isso é, se a classe define métodos hasNext e next com tipos de retorno coincidentes, ela é considerada um iterador; se ela define um método iterador que retorna um Iterator<T> ela é considerada um tipo iterável.

class MyStringIterator {
    var s:String;
    var i:Int;
    public function new(s:String) {
        this.s = s;
        i = 0;
    }
    public function hasNext() {
        return i < s.length;
    }

    public function next() {
        return s.charAt(i++);
    }
}

class Main {
    static public function main() {
        var myIt = new MyStringIterator("string");
        for (chr in myIt) {
            trace(chr);
        }
    }
}

O tipo MyStringIterator nesse exemplo qualifica um iterador: Ele define um método hasNext que retorna Bool e um método next que retorna String, tornando o compátivel com Iterator<String>. O método main o instancia e então itera sobre ele.

class MyArrayWrap<T> {
    var a:Array<T>;
    public function new(a:Array<T>) {
        this.a = a;
    }

    public function iterator() {
        return a.iterator();
    }
} 

class Main {
    static public function main() {
        var myWrap = new MyArrayWrap([1, 2, 3]);
        for (elt in myWrap) {
            trace(elt);
        }
    }  
}

Aqui nós não definimos um iterador completo como no exemplo anterior, ao invés disso definimos que MyArrayWrap<T> tem um método iterator, encaminhando efetivamente o método iterador do tipo envelopado Array<T>.

\section{Amarração de funções}

O Haxe 3 permite 3 formas de amarração de funções com argumentos parcialmente aplicados. Cada tipo de função pode ser considerar a existência de uma campo de amarração bind, que pode ser chamado com o número desejado de argumentos de forma a criar uma nova função. Isso é demontrado aqui:

class Bind {
    static public function main() {
        var map = new Map<Int,String>();
        var f = map.set.bind(_, "12");
        $type(map.set); // Int -> String -> Void
        $type(f); // Int -> Void
        f(1);
        f(2);
        f(3);
        trace(map); // {1 => 12, 2 => 12, 3 => 12}
   }
}

A linha 4 amarra a função map.set a uma variável chamada f e aplica 12 como um segundo argumento. O caractere sublinhado _ é usado para denotar que esse argumento não é amarrado, o que é mostrado comparando os tipos de map.set e f: O argumento amarrado String é efetivamente cortado do tipo, tornandoo tipo Int->String->Void em Int->Void.

Uma chamada de f(1) chama realmente map.set(1,"12"), as chamadas para f(2) e f(3) são análogas. A última linha prova que os três índices são de faot mapeados para o valor "12".

O sublinhado _ pode ser omitido para os argumentos que vem depois dele, se o primeiro argumento fosse amarrado através de map.set.bind(1), disponibilizaríamos uma função String->Void que definiria o  valor para o índice 1 na chamada de f.

\Trivia{Retrochamada}{Antes do Haxe 3, o Haxe costumava conhecer uma palavra-chave callback que poderia ser chamada com um argumento de função seguido por um número de argumentos de amarração. O nome se originou de um uso comum onde uma função de retrochamada (callback) é creada com o objeto this sendo amarrado. Callback  permitiria a amarração de argumentos apenas da esquerda para a direita pois não havia suporte para o caractere _. A escolha pelo uso de _ foi controversa e muitas outras sugestões foram feitas, nenhuma delas considerada superior. Afinal, o sublinhado _ ao menos parece que está dizendo "preencha o valor aqui", o que descreve a semântica de forma agradável.}

\section{Metadados}

Diversos constructs podem ser atribuídos com metadados personalizados:

 - declarações de classe e enums

 - campos de classes

 - Constructors de enums

 - Expressões

Essas informações de metadados podem ser obtidas em tempo de execução através da API haxe.rtti.Meta:

import haxe.rtti.Meta;

@author("Nicolas")
@debug

class MyClass {
    @range(1, 8)
    var value:Int;

    @broken
    @:noCompletion
    static function method() { }
}
class Main {
    static public function main() {
        trace(Meta.getType(MyClass)); 
                      // { author : ["Nicolas"], debug : null }
    trace(Meta.getFields(MyClass).value.range); // [1,8]
    trace(Meta.getStatics(MyClass).method); // { broken: null }
    }
}

Nós podemos facilmente identificar metadados pelo caractere inicial @, seguido pelo nome do metadado e, opcionalmente por um número de argumentos constantes separados por vírgulas fechados por parentes.

  - A classe MyClass tem um metadado author com um único argumento "Nicolas", bem como um metadado debug sem argumentos.

  - A variável membro value tem um metadado range com dois argumentos do tipo Int; os argumentos são 1 e 8.

  - O método estático method tem um metadado broken ser argumentos, bem como um metadado :noCompletion também sem argumentos.

  O método main acessa os valores desses metadados usando a API. O output revela a estrutura dos dados obtidos:

  - Há um campo para cada metadado, com o nome do campo sendo o nome do metadado.

  - Os valores de campo são os argumentos do metadado. Se não há argumentos, o valor do campo é null. De outra forma o valor é um array, com um elemento por argumento.

  - Metadados que começam por dois pontos : são omitidos. Esse tipo de dado é conhecido por metadado de compilação.

Os valores permitidos para argumentos de metadados são:

- Constantes (ver seção)

- Declaração de arrays (ver seção) (se todos os seus elementos forem qualificados corretamente)

- Declaração de objetos (ver seção) (se todos os seus elementos forem qualificados)

\section{Controle de Acessos}

O controle de acessos pode se4r usado se as opções de visibilidade básica não são suficientes. Ele é aplicável em nível de classe e em nível de campos e entende duas diretivas:

Permissão de acesso: Uma dada classe ou campo da classe tem o seu acesso garantido ao alvo usando o metadado :allow(target) (ver seção).

Acesso forçado: Um alvo é forçado a permitir o acesso para a classe ou campo usando o metadado :acess(target) (ver seção).

Nesse contexto, um alvo pode ser um caminho separado por pontos (dot-path) para:

  - um campo de classe,

  - uma classe ou tipo abstrato, ou

  - um pacote.

Se for uma classe ou um tipo abstrato, a modificação de acesso se estende a todos os campos daquele tipo. Da mesma forma, se for um pacote, a modificação de acesoo se estende a todos os tipos daquele pacote e recursivamente a todos os campos desses tipos

@:allow(Main)
class MyClass {
    static private var foo: Int;
}

class Main {
    static public function main() {
        MyClass.foo;
    }  
}

Aqui, MyClass.foo pode ser acessado do método main porque MyClass recebe a anotação @:allow(Main). Isso também funcionaria com @:allow(Main.main) e ambas as versões poderiam alternativamente ser anotadas ao campo foo ao invés da classe MyClass

class MyClass {
    @:allow(Main.main)
    static private var foo: Int;
}
class Main {
    static public function main() {
        MyClass.foo;
    } 
}

Se um tipo não pode ser modificado para permitir essa espécie de acesso, o método de acesso dever forçar o acesso:

class MyClass {
    static private var foo: Int;
}
class Main {
    @:acess(MyClass.foo)
    static public function main() {
        MyClass.foo;
    }
}

A anotação @:acess(MyClass.foo) efetivamente subverte a visibilidade do campo foo dentro do método main.

\trivia{Sobre a escolhad de metadados}{A funcionalidade da linguagem de controle de acessos usa a sintaxe de metadados ao invés de sintaxe específica da linguagem. Há diversas razões para isso:

  - Sintaxe adicional frequentemente adiciona complexidade ao processamento de separação de palavras da linguagem (parsing) e também adiciona (muitas) novas palavras-chave.

  - Sintaxe adicional exige aprendizado adicional pelo usuário da linguagem, enquanto a sintaxe de metadados é algo que já é conhecido.

  - A sintaxe de metadados é flexível o bastante para permitir a extensão dessa funcionalidade.

  - Os metadados podem ser acessados/gerados/modificados pelas macros de Haxe.

É claro, o principal retrocesso do uso da sintaxe de metadados é que você não recebe um relatório de erros no caso de digitar errado tanto a chave do metadado (@:acesss por exemplo) ou o nome da classe/pacote. Entretanto, com essa funcionalidade você poderá obter um erro quando você tentar acessar um campo privado que você não tem acesso, portanto não há a possibilidade de erros silenciosos.

Desde Haxe 3.1.0

Se o acesso é permitido a uma interface (ver seção), ele se extende a todas as classes implementando aquela interface:


class MyClass {
    @:allow(I)
    static private var foo: Int;
}
interface I { }
class Main implements I {
    static public function main() {
    MyClass.foo;
    }
}

Isso também funciona para o acesso garantido a classes pai, caso em que se estende à todas classes descendentes.

\trivia{Funcionalidade quebrada}{A extensão de acesso à classes descendentes e classes implementadoreas deveria funcionar no Haxe 3.0 e foi, inclusive documentada dessa forma. Enquanto se escrevia esse manual se descobriu que essa parte da implementação de controle de acesso simplesmente estava faltando.}

\section{Constructors alinhados}

Desde Haxe 3.1.0

Se um constructor é declarado para ser alinhado (ver subseção), o compilador poderá tentar otimizá-lo por fora em certas situações. Há diversos requerimentos para isso funcionar:

  - O resultado da chamada do constructor deve ser diretamente atribuído a uma variável local.

  - A expressão do campo constructor deve conter apenas atribuições a seus campos.

O exemplo seguinte demonstra o alinhamento de constructor:

class Point {
    public var x:Float;
    public var y:Float;
    
    public inline function
    new(x:Float, y:Float) {
        this.x = x;
        this.y = y;
    }
}

class Main {
    static public function main() {
        var pt = new Point(1.2, 9.3);
    }
}

A observação do exposto em Javascript revela o efeito:

Main.main = function() {
    var pt_x = 1.2;
    var pt_y = 9.3;
};

\section{Remoting}

Parte II - Compiler Referenca

\chapter{Uso do compilador}

N. do T.
(Texto da Introdução ao Haxe)

\section{Uso básico}

O compliador de Haxe é tipicamente chamado da linha de comando com diversos argumentos que devem responder duas questões:

1. O que deve ser compilado?

2. Qual deve ser o output?

Para responder a primeira pergunta, é normalmente suficiente oferecer um caminho de classe via o argumento "-cp caminho", junto com a classe main a ser compilada pelo argumento "-main pacote.modulo.classe". O compilador do Haxe resolve, então, o arquivo da classe main e começa a compilação.

A segunda questão normalmente se resume a fornecer um argumento especificando o target desejado. Cada target do Haxe tem uma opção de linha de comando, como -js nome_do_arquivo para Javascript e -php diretório para PHP. Dependendo  da natureza do target, o valor do argumento é um nome de arquivo (para -jf, -swf e -neko) ou um caminho para um diretório.

\section{Argumentos comuns} 
 Input:
 - cp caminho: Adiciona um caminho de classe onde arquivos fonte ou pacotes .hx (subdiretórios) podem ser encontrados.

 -lib nome_da_biblioteca: Adiciona uma biblioteca Haxelib

 -main pacote.módulo.classe: Define a classe main

Output:

 -js nome_arquivo: Gera o código fonte em Javascript no arquivo especificado.

 -as3 diretório: Gera o código fonte de Actionscript 3 no diretório especificado.

-swf nome_arquivo: Gera o arquivo especificado como uma .swf de Flash.

-neko nome_arquivo: Gera um binário de neko como o arquivo especificado.

-php diretório: Gera código fonte PHP no diretório especificado.

-cpp diretório: Gera código fonte em C++ no diretório especificado e o compila usando um compilador de C++ nativo.

-cs diretório: Gera código fonte C# no diretório especificado.

-java diretório: Gera código fonte em Java no diretório especificado e o compila usando o Compilador Java.

-python nome_arquivo: Gera código fonte em Python no arquivo especificado.



\chapter{Funcionalidades do compilador}

\section{Metadados de compilação}

\section{Eliminação de código morto}

A eliminação de código morto (DCE for Dead Code Elimination) é uma funcionalidade que remove código não utilizado do resultado. Depois de tipificar o compilador avalia os pontos de entrada (geralmente o método main) e recursivamente determina que tipos e campos são usados. Os campos utilizados são marcados adequadamente e os campos não marcados são removidos de suas classes.

DCE tem trê modos que são definidos quando chamados pela linha de comando:

-dce std: Apenas as classes na Biblioteca padrão são afetadas pelo DCE. Isso é o modo padrão para todos os targets, exceto Javascript

-dce no: Nenhuma eliminação de código morto é executada.

-dce full: Todas as classes são afetadas pelo DCE. Esse é o modo default quando o target é Javascript.

O algoritmo de DCE funciona bem com código tipado, mas pode falhar quando se usa dynamic (ver seção) e reflection(ver seção). Isso pode exigir a marcação explicta de campos ou classes que são utilizadas, atribuindo-lhes os seguinte metadados:

@:keep: Se for usado em uma classe, a classe e todos os seus campos não serão afetados pelo DCE.

@:keepSub: Se usado em uma classe, funciona com @:keep na classe anotada e em todas as suas subclasses.

@:keepInit: Normalmente, uma classe que teve tosos os seus campos removidos pelo DCE (ou é vazia mesmo) é removida do resultado. Ao usar esse metadado, classes vazias são mantidas.

Se uma classe precisa ser marcada com @:keep da linha de comando ao invés da edição do código fonte, há uma macro de compilação disponível para fazer isso: --macro keep('type dot path'). Veja haxe.macro.Compiler.keep (http://api.haxe.org/haxe/macro/Compiler.html#keep) para detalhes sobre essa macro. Ela irá marcar o pacote, módulo ou subtipo a ser mantido pelo DCE e incluí-los na compilação.

O compilador automaticamente define um sinalizador de compilação dce com valor de "std", "no" ou "full" dependendo do modo ativao. Isso pode ser usado em compilação condicional.

\trivia{Reescrita do DCE}{O DCE foi originalmente implementado no Haxe 2.07. Essa implementação foi considerada uma função a ser usada quando o código é explicitamente tipado. O problema com ela é que diversas funcionalidades, as mais importantes sendo as interfaces, levavam todos os campos de classe a serem tipados de forma a verificar a segurança de tipos. Isso subverteu o DCE efetivamente todo, solicitando sua reescrita para o Haxe 2.10}

\trivia{DCE e try.haxe.org}{O DCE para Javascript viu inúmeras melhorias quando o website http://try.haxe.org foi publicado. A recepção inicial do código gerado em Javascript foi variada, levando a seleção mais delicada de qual código deveria ser eliminado}

\section{Completion}

\subsection{Acesso a campos}
\subsection{Chamada de argumentos}
\subsection{Uso}
\subsection{Posição}
\subsection{Nível superior}

\section{Recursos}

O Haxe oferece um sistema de embarcação de recursos simples que pode ser usado par embarcar arquivos diretamente na aplicação compilada.

Enquanto pode não parecer ótimo embarcar coisas grabdes como imagens ou música no arquivo da aplicação, isso vem a ser conveniente para embarcar pequenos recursos como configurações ou dados XML.

\subsection{Embarcação de recursos}

Arquivos externos podem ser embarcados usando o argumento de compilação -resource

-resource hello_nessage.txt@wellcome

O string depois do símbolo é o identificador do recurso que é usado no código para acolher o recurso. Se for omitido (bem como o @) o nome do arquivo será o identificador do recurso.

\subsection{Acolhimento de recursos de texto}

Para acolher o conteúdo de um recurso embarcado, utilizamos o método estático getString de haxe.Resource e lhe passamos um identificador de recursos

class Main {
   static function main() {
        trace(haxe.Resource.getString("welcome"));
   }
}

O código acima ira exibir o conteúdo do arquivo hello_message.txt que foi incluído anteriormente usando wellcome como identificador

\subsection{Acolhimento de recursos binários}

Ainda que não seja recomendado embarcar grandes arquivos binários na aplicação, ainda pode ser útil embarcar dados binários. A representação binária de um recurso embarcado pode ser acessada com o método estático getBytes de Haxe.Resource:

class Main {
    static function main() {
        var bytes = haxe.Resource.getBytes("welcome");
        trace(bytes.readString(0, bytes.length));
    }
}

O tipo de retorno do método getBytes é haxe.io.Bytes, que é um objeto que fornece acesso a bytes individuais dos dados.

\subsection{Detalhes de implementação}

O Haxe usa a embarcação de recursos nativa da plataforma target se houver uma, se não fornece sua própria implementação.

  - Recursos em Flash são embarcados como definições de ByteArray

  - Recursos em C# são incluídos no assembly compilado.

  - Recursos em Java são empacotados na arquivo JAR resultante

  - Recursos em C++ são armazenados nas constantes de array de bites globais.

  - Recursos em Javascript são seriados no formato de serialização do Haxe e armazenados no campo estático da classe haxe.Resource.

  - Recursos em Neko são armazenados como strings em um campo estático da classe haxe.Resource

\section{Informação de tipos em tempo de execução}

Desde Haxe 3;2.0

O compilador do haxe gera informação de tipos em tempo de execução para classes que são marcadas com o metadado :rtti (RTTI for runtime type infomation) ou para classes que estendam classes com essa marcação. Essa informação é armazenada como um string XML em um campo estático __rtti e pode ser processado através da haxe.rtti.XmlParser . A estrutura resultante é descrita em RTTI structure (vers subseção)

O tipo haxe.rtti.Rtti foi introduzido de forma a simplificar o trabalho com RTTI. A extração dessa informação agora é muito fácil:

@:rtti
class Main {
    var x:String;
    static function main() {
        var rtti = haxe.rtti.Rtti.getRtti(Main);
        trace(rtti);
    }
}

\subsection{A estrutura da informação de tipos em tempo de execução}

Informação geral de tipos

path: O caminho de tipo para o tipo

module: O caminho de tipo do módulo que contem o tipo

file: O caminho com barras (/) completo para o arquivo .hx que vonté o tipo. Esse pode ser null no caso de não existir o arquivo, por exemplo, se o tipo é definindo através de uma macro (ver capítulo)

params: Um array de strings representando os nomes dos parâmetros de tipo que o tipo tem. A partir do Haxe 3.2.0, isso não inclui as restrições (ver seção) 

doc: A documentação do tipo. Essa informação só é disponível se o sinalizador de compilação -D use_rtti_doc estiver em ação. De outra forma, ou se o tipo não tiver documentação, o valor é null

isPrivate: Se o tipo é ou não privado (ver seção)

platforms: Uma lista de strings representando os targets onde o tipo está disponível

meta: Os metadados com que o tipo foi marcado.

Informaçao de tipo para classes:

isExtern: Se a classe é ou não externalizada (ver seção)

isInterface: Se a classe é ou não é uma interface (ver seção)

superClass: A classe pai da classe defininda por seu caminho de tipo e lista de parâmetros de tipo.

interfaces: A lista de interfaces definidas por seu caminho de tipo e lista de parâmetros de tipo

fields: A lista de seus campos de classe membros (ver capítulo) descritas em Informações de campo de classe (ver subseção).

statics: A lista de campos de classe estáticos, descrita em Informações de campo de classe (ver subseção).

tdynamic: O tipo que está implementado dinamicamente (ver seção) pela classe, ou null se o tipo não existe.

Informação de tipo para enums

isExtern: Se o enum é ou não externalizado (ver seção)

constructors: A lista dos constructors do enum

Informações para tipo abstratos:

to: um array contendo as fusões implicitamente definidas para qual o tipo se converte (ver seção).

from: um array contendo as fusões implicitamente definidas do qual o tipo se converte (ver seção). 

impl: A informação de tipo de classe da classe de implementação (ver seção)

athis: O tipo subjacente do abstrato (ver seção).

Informações para campos de clase

name: O nome do campo.

type: o tipo do campo

isPublic: Se o campo é ou não público (ver seção)

isOverride: Se o campo sobrescreve ou não outro campo

doc: A documentação do campo. Essa informação só é disponível se o sinalizador de compilação -D use_rtti_doc estiver em ação (ver seção). De outra forma, ou se o tipo não tiver documentação, o valor é null

get: O comportamento de acesso de leitura do campo (ver seção)

set: O comportamento de acesso à escrita no campo (ver seção)

params: um array de strings representando os nomes dos parâmtros de tipo que o campo tem (ver seção). A partir do Haxe 3.2.0, isso não inclui as restrições (ver seção).

platforms: Uma lista de strings representando os targets onde o campo está disponível.

meta: Os metadados com os quais o campo foi marcado.

line: O número da linha onde o campo é definido. Essa informação só está disponível se o campo tem uma expressão. De outra forma é null.

overloads: Uma lista dos overloads para os campos, ou null se não existe overload.

Informações para constructors de enum

nome: O nome do constructor.

args: a lista dos argumentos que o constructor tem, ou null se não há argumentos disponíveis.

doc: A documentação do constructor. Essa informação só é disponível se o sinalizador de compilação -D use_rtti_doc estiver em ação. De outra forma, ou se o tipo não tiver documentação, o valor é null

platforms: Uma lista de strings representando os targets onde o campo está disponível.

meta: Os metadados com os quais o constructor foi marcado.

\chapter{Macros}

Macros são, sem nenhuma dúvida, a funcionalidade mais avançada do Haxe. Elas frequentemente são percebidas como uma magia sombria que apenas alguns eleitos são capazes de dominar, ainda que não exista nada de mágico(e certamente nada de sombrio) sobre elas.

\definition{Arvore Abstrata de Sintaxe (AST for Abstract Sintax Tree)} 
A AST resulta do processamento da separação das palavras (parsing) do código fonte em uma estrutura tipada. Essa estrutura é exposta para as macros através dos tipos definidos no arquivo haxe/macro/Expr.hx da Biblioteca Padrão do Haxe}

Figura 9.1

Um macro básica é uma transformação sintática. Ela recebe zero ou mais expressões (ver capítulo) e também retorna uma expressão. Se uma macro é chamada, ela efetivamente insere código no local de onde foi chamada. Com relação a isso, ela poderia ser comparada a um preprocessador como #define in C++, mas uma macro de Haxe não é uma ferramenta de substituição de texto.

Nós podemos certamente identificar diferentes espécies de macros, que são executadas em diferentes estágios da compilação:

Macros de Inicialização: Essas são fornecidas pela linha de comando usando o parâmetro de compilação --macro. Elas são executadas depois que os argumentos de compilação foram processados e o contexto para tipificação já foi criado, mas antes que qualquer tipificação seja feita (ver Macros de Inicialização (ver seção)).

Macros de Build (Montagem): Essas são definidas para classes, enums e abstratos através do metadado @:build ou @:autobuild. Elas são executadas por tipo, depois que o tipo foi definido (incluindo sua relação com outro tipos, como herança para classes) mas antes que os campos seja tipificados (Ver Montagem de Tipos (seção)).

Macros de expressão: Essa são funções normais que são executadas tão logo sejam tipadas.

\section{Contexto de macros}

\definition{Contexto de macro}{O contexto de macor é o ambiente no qual a macro é executada. Dependendo do tipo de macro, ele pode ser considerado como uma classe em montagem ou como uma função sendo tipificada. Informações de contexto podem ser obtidas através da API haxe.macro.Context .}

Macros de Haxe tem acesso a diferentes informações contextuais dependendo do tipo de macor. Além de levantar tais informações, o contexto também permite algumas modificaçãos tais como a definição de um novo tipo ou registrar certas retrochamadas. É importante entender que nem toda informação está disponível para todas as espécies de macro, como os exemplos seguintes demonstram:

  - Macros de inicialização vão achar que os métodos: Context.getLocal*() retornam null. Não há tipo local ou método no contexto de uma macro de inicialização.

  - Apenas macros de build recebem um valor adequado de Context.getBuildFields(). Não há campos em montagem para as outras espécies de macro.

  - Macros de build tem um tipo local (se incompletas), mas não tem métodos locais, então Context.getLocalMethod retorna null.

A API de contexto é complementada pela API haxe.macro.Compiler detalhada em Macros de Inicialização (ver seção). Enquanto essa API está disponível  para todas espécies de macros, cuidado deve ser tomado para qualquer modificação fora das macros de inicialização. Isso deriva da limitação natural da ordem de montagem não definida (ver seção), o que pode levar, por exemplo, a definição de um sinalizador (flag) através de Compiler.define() a ter efeito antes ou depois de uma verificação de compilação condicional daquele sinalizador.

\section{Arguments}

Na maior parte do tempo, argumentos para macros são expressões representadas como uma instância de uma expressão de enum. Como tal, elas são separadassintaticamente, mas não são tipificadas, implicando que elas podem ser qualquer coisa que se conforme com as regras de sintaxe do Haxe. A macor pode então inspecionar suas estruturas, ou (tentar) conseguir seu tipo usando haxe.macro.Context.typeof()

É importante entender que argumentos para macros não tem garantia de serem valorados, então qualquer efeito colateral não tem garantia de ocorrer. Por outro lado, é importante entender que uma expressão como argumento pode ser duplicada por uma macro e usada multiplas vezes na expressão de retorno:

import haxe.macro.Expr

class Main {
   static public function main () {
       var x = 0;
       var b = add(x++);
       trace(x); // 2
   }

   macro static function add(e:Expr) {
       return macro $e + $e;
   }
}

A macro add é chamada com argumento x++ e dessa forma retorna x++ + x++ usando a consolidação de expressão (ver seção), fazendo com que x seja incrementado duas vezes.

\subsection{ExprOf}

Uma vez que Expr é compatível com qualquer entrada possível, o Haxe fornece o tipo haxe.macro.ExprOf<T>. Na maioria das vezes, esse tipo é idêntico a Expr, mas ele permite restringir o tipo das expressões aceitas. Isso é útilquando se combinam macros com extensões estáticas (ver seção):

import haxe.macro.Expr;
using Main;

class Main {
    static public function main() {
       identity("foo");
       identity(1);
       "foo".identity();
       // Int has no field identity
       //1.identity();
    }
    macro static function identity(e:ExprOf<String>) {
        return e;
    }
} 

As duas chamadas diretas para identity são aceitas, mesmo que o argumento seja declarado como ExprOf<String>. Pode ser surpreendente que Int 1 seja aceito, mas é uma consequência lógica do que foi explicado sobre argumentos de macros (ver seção): As expressões de argumento nunca são tipificadas, então não é possível para o compilador verificar sua compatibilidade através da unificação (ver seção). 

Isso é diferente para as duas próximas linhas que estão usando extensões estáticas (observe o using Main): Para essas duas é mandatória a tipagem do lado esquerdo ("foo" e 1) primeiro, de forma a dar sentido para o acesso ao campo identity. Isso torna possível verificar tipos em relação aos tipos do argumento, o que faz com que 1.identity() não considerar Main.identity() como um campo adequado.

\subsection{Constantes expressões}

Uma macro pode ser declarada para esperar constantes como argumentos:

class Main {
    static public function main() {
        const("foo", 1, 1.5, true);
    }

    macro static function
    const(s:String, i:Int, f:Float, b:Bool) {
        trace(s);
        trace(i);
        trace(f);
        trace(b);
        return macro null;
    }  
}

Com isso não é necessário dar a volta em expressões uma vez que o compilador pode usar as constantes fornecidas diretamente.

\subsection{Argumento final}

Se o argumento final de uma macro é do tipo Array<Expr>, a macro aceita um número arbitrário de argumentos extras que estão disponíveis de dentro do array:

import haxe.macro.Expr;

class Main {
    static public function main() {
        myMacro("foo", a, b, c);
    }

    macro static function
    myMacro(e1:Expr, extra:Array<Expr>) {
        for (e in extra) {
        trace(e);
        }
        return macro null;
    }
}

\section{Consolidação (Reitification)}

(N. do T.: Reitification pode ser traduzido eventualmente como reitificação, realização, concretização: significando tornar real algo que é abstrato)

O compilador do Haxe permite a consolidação de expressões, tipos e classes para simplificar o trabalho com macros. A sintaxe para consolidação é macroexpr, onde expr é qualquer expressão valida em Haxe.

\subsection{Consolidação de expressões}

A consolidação de expressões é usada para criar instâncias de haxe.macro.Expr de uma forma conveniente. O compilador do Haxe aceita a sintaxe usual do Haxe e a traduz em um objeto expressão. Ele suporta diversos mecânismos de escape, todos disparados pelo caractere $:

${} ou $e{}: Expr -> Expr ; Isso pode ser usado para compor expressões. A expressão delimitada por { } é executada, com seu valor sendo utilizado em seu lugar.

$a: Expr -> Array<Expr> ; Se usada em um local onde um Array<Expr> é esperado (por exemplo. chamada de argumentos ou elementos de bloco) $a{} trata seu valor como se fosse aquele array. De outra forma ela gera uma declaração de array.

$b{}: Array<Expr> -> Expr ; gera um bloco de expressões do array de expressões dado.

$i{}: String -> Expr ; Gera um identificador do string dado.

$p{}: Array<String> -> Expr ; Gera um campo expressão do array de strings dado.

$v{}: Dynamic -> Expr ; Gera uma expressão dependente do tipo de seu argumento. Isso só funciona garantidamente para tipos básicos (ver seção) e instâncias de enums (ver seção).

Esse tipo de consolidação só funciona em lugares onde a estrutura interna espera uma expressão. Isso exclui objeto.${nomeDeCampo}, mas funciona para objeto.$nomeDeCampo. Isso é verdade em todos os lugares onde a estrutura interna espera um string:

  - acesso ao campo objeto.$nome

  - nome da variável var $nome = 1;

Desde Haxe 3.1.0

  - nome de campo { $nome: 1}
 
  - nome de função function $nome() { }

  - nome de variável no catch try e() catch ($nome:Dynamic) { }

\subsection{Consolidação de tipos}

A consolidação de tipos é usada para criar instâncias de haxe.macro.Expr.ComplexType de uma forma conveniente. Ela é identificada por macro : Type, onde Type pode ser qualquer expressão de caminho de tipo válido. Isso é similar a indicação de tipo explícito no código normal, por exemplo, para variáveis na forma x:Type.

Cada constructor de ComplexType tem uma sintaxe distinta:

TPath: macro : pack.Type

TFunction: macro : Arg1 -> Arg2 -> Return

TAnonymous: macro : { field: Type }

TParent: macro : (Type)

TExtend: macro : (> Type, field: Type}

TOptional: macro : ?Type

\subsection{Consolidação de classes}

Também é possível usar a consolidação para obger uma instância de haxe.macro.Expr.TypeDefinition . Isso é indicado pela sintaxe macro class, como mostrado aqui:

class Main {
    macro static function
    generateClass(funcName:String) {
        var c = macro class MyClass {
            public function new() { }
            public function $funcName() {
                trace($v{funcName} + " was called");
            }  
        }
        haxe.macro.Context.defineType(c);
        return macro new MyClass();
    }
    public static function main() {
        var c = generateClass("myFunc");
        c.myFunc();
    }
}

A instância de TypeDefinition gerada é tipicamente passada para haxe.macro.Context.defineType de forma a adicionar um novo tipo ao contexto de chamadas (e não ao próprio contexto da macro)
Esse tipo de consolidação também pode ser útil para obter instâncias de haxe.macro.Expr.Field, que estão disponíveis a partir do array fields do TypeDefinition gerado.

\section{Ferramentas}

A Biblioteca Padrão do Haxe vem com um conjunto de "ferramentas de classes"para simplificar o trabalho com macros. Essas classes funcionam melhor como extensões estáticas (ver seção) e podem ser trazidas para o contexto individualmente ou como um todo através de using haxe.macro.Tools. Essas classes são:

ComplexTypeTools: Permitem escrever instâncias de ComplexType em um formato legível para humandos. Também permitem determinar o Type correspondente a um ComplexType.

ExprTolls: Permitem a escrita de instâncias de Expr em um formato legível para humanos. Também permitem expressões de iteração e mapeamento.

MacroStringTools: Oferecem operações úteis sobre strings e expressçoes de strings no contexto de macros.

TypeTools: Permitem a escrita de instâncias de Type em formato legível para humanos. Também oferecem diversas operações sobre tipos, como unificação (ver seção) ou conseguir o ComplexType correspondente.

\trivia{A biblioteca tinkerbell e porque Tools.hx funciona}{Aprendemos sobre as extensões estáticas que usar um módulo implica em trazer todos os seus tipos para a o contexto de extensão estática. Disso resulta que, tal tipo pode bem ser um typedef para outro tipo. O compilador então considera essa parte tipificada de um módulo e estende a extensão estática concordantemente.

Esse "truque" foi usado na biblioteca tinkerbell de Juraj Kirchheim exatamente com essa intenção. Tinkerbell ofereceu muitas ferramentas de macro bem antes de leas serem colocadas no Compilador do Haxe e na Biblioteca Padrão do Haxe. Ela permanece uma biblioteca primária para ferramentas de macro adicionais e oferece outras funcionalidades igualmente úteis.}

\section{Montagem de tipos}

Macros de montagem de tipo (Type Building) são diferentes de macros de expressões em diversas formas:

  - Elas não retornam expressões, mas um array de campos de classe. O seu tipo de retorno deve ser explicitamente definido para Array<Haxe.macro.Expr.Field>.

  - Seus contextos (ver seção) não tem métodos locais nem variáveis locais.

  - Seus contextos tem campos de montagem (build), disponíveis apartir de haxe.macro.getBuildFields()

  - Elas não são chamadas diretamente, mas são argumentos para um metadado @:build ou @:autobuild (ver seção) em uma declaração de classe (ver seção) ou enum (ver seção).

O exemplo seguinte demonstra a montagem de tipo. Observe que ele é divido em dois arquivos por uma razão: Se um módulo contém uma função de macro, ele tem que ser igualmente tipificado dentro do contexto de macro. Isso  é frequentemente um problema para macros de montagem de tipos porque o tipo a ser montado só poderia ser carregado em seu estado incompleto, antes que a macro de montagem tenha sido executada. Nós recomendamos a definição de macros de montagem de tipos dentro de seu próprio módulo.

import haxe.macro.Context;
import haxe.macro.Expr;

class TypeBuildingMacro {
    macro static public function
    build(fieldName:String):Array<Field> {
        var fields = Context.getBuildFields();
        var newField = {
            name: fieldName,
            doc: null,
            meta: [],
            access: [AStatic, APublic],
            kind: FVar(macro : String,
                       macro "my default"),
            pos: Context.currentPos()
        };
        fields.push(newField);
        return fields;
    }
}     


@:build(TypeBuildingMacro.build("myFunc"))
class Main {
    static public function main() {
        trace(Main.myFunc); // my default
    }
}

O método build de TypeBuildingMacro executa três passos:

1. Obtém os campos de montagem usando Context.getBuildFields().

2. Declara um novo campo haxe.macro.expr.Field usando o argumento de macro funcName como nome do campo. Esse campo é uma variável tipo String com um valor padrão "my default" (do campo kind) e é público e estático (do campo acesso).

3. Adiciona o novo campo ao array de montagem de campos e o retorna.

Essa macro é o argumento do metadado @:build da classe Main. Tão logo esse tipo seja requerido, o compilador faz o seguinte:

1. Analisa a sintaxe do arquivo com o módulo, incluindo os campos de classe.

2. Define o tipo, incluindo sua relação com outros tipos através de herança (ver seção) e interface (ver seção).

3. Executa a macro de montagem de tipo de acordo com o metadado @:build.

4. Continua  a tipificação de classes normalmente com os campos retornados pela macro de montagem de tipos.

Isso permite adicionar e modificar campos de classe a vontade em uma macro de montagem de tipos. Em nosso exemplo a macro é chamada com um argumento "myFunc", fazendo Main.myFunc um acesso de campo válido.

Se uma macro de montagem de tipo não modificasse nada, a macro pode retornar null. Isso indica ao compilador que nenhuma mudança é pretendida e é preferível o retornar Context.getBuildFields

\section[Montagem de enum}

A montagem de enums (ver seção) é análoga a montagem de classes com um mapeamento simples:

  - Constructors de enum sem argumentos são campos-variáveis FVar.

  - Constructors de enum com argumentos são campos-métodos FFun

import haxe.macro.Context;
import haxe.macro.Expr;

class EnumBuildingMacro {
    macro static public function build():Array<Field> {
        var noArgs = makeEnumField("A", FVar(null, null));
        var eFunc = macro function(value:Int) { };
        var fInt = switch (eFunc.expr) {
                   case EFunction(_,f): f;
                   case _: throw "false";
        }
        var intArg = makeEnumField("B", FFun(fInt));
        return [noArgs, intArg];
    }

    static function makeEnumField(name, kind) {
        return { name: name,
                 doc: null,
                 meta: [],
                 access: [],
                 kind: kind,
                 pos: Context.currentPos()
        }
     }  
}


@:build(EnumBuildingMacro.build())
enum E { }
    class Main {
        static public function main() {
            switch(E.A) {
            case A:
            case B(v):
        }
    }
}  


Porque o enum E está marcado com um metadado :build, a macro chamada monta dois constructors A e B "nele". O primeiro é adicionado com o kind sendo FVAr (null, null) implicando que é um constructor sem argumentos. Para o último, usamos consolidação (ver seção) para obter uma  instância de haxe.macro.Expr.Function com um único argumento Int.

O método main prova a estrutura do nosso enum gerado testando sua correspondência. Nós podemos ver que o tipo gerado é equivalente a isso

enum E {
    A;
    B(value:Int);
}

\subsection{@:autobuild}

Se uma classe tem o metadado @:autobuild, o compilador gera o metadado @:build em todas as classes que a estendem. Se uma interface tem o metadado @:autobuild, o compilador gera o metadado @:build em todas as classes que a implementam ou a estendem. Observe que @:autobuild não implica em :build an própria classe/interface.

import haxe.macro.Context;
import haxe.macro.Expr;

class AutoBuildingMacro {
    macro static public
    function fromInterface():Array<Field> {
        trace("fromInterface: " + Context.getLocalType());
        return null;
    }

    macro static public
    function fromBaseClass():Array<Field> {
    trace("fromBaseClass: " + Context.getLocalType());
    return null;
    }
}

@:autoBuild(AutoBuildingMacro.fromInterface())
interface I { }

interface I2 extends I { }

@:autoBuild(AutoBuildingMacro.fromBaseClass())
class Base { }

class Main extends Base implements I2 {
    static public function main() { }
}

Isso resulta, durante a compilação:

AutoBuildingMacro.hx:6:
fromInterface: TInst(I2,[])
AutoBuildingMacro.hx:6:
fromInterface: TInst(Main,[])
AutoBuildingMacro.hx:11:
fromBaseClass: TInst(Main,[])

É importante manter em mente que a ordem da execução dessas macros não é definida, o que é detalhado em Ordem de Montagem (ver seção)

\subsection{Limitações}

\subsection{Macro dentro de macro}

\subsection{Extensão estática}

Os conceitos de extensçao estática e macros são um tanto conflitantes: enquanto o primeiro exige um tipo conhecido de forma a determinar as funções utilizadas, macros são executadas antes da tipagem sobre a sintaxe pura. Não é, portanto, surpreendente que a combinação dessas duas funcionalidades pode levar a pontos de argumentação. O Haxe 3.0 tentaria converter expressões tipadas de volta a expressões sintáticas, o que não é sempre possível e pode perder informações importantes. Nós recomendamos o uso disso com cautela.

Desde Haxe 3.1.0

A combinação de extensões estáticas e macros foi retrabalhada para a versão 3.1.0. O compilador do Haxe nem mesmo tenta encontrar a expressão original para o argumento da macro e ao invés disso passa uma expressão especial @:this this. Ainda que a estrutura da expressão não traga nenhuma nova informação, a expressão ainda pode ser tipada corretamente:

import haxe.macro.Context
import haxe.macro.Expr;

using Main;
using haxe.macro.Tools;

class Main {
   static public function main() {
         "foo".test();
    }
    macro static function
    test(e:ExprOf<String>) {
        trace(e.toString()); // @:this this
        // TInst(String,[])
        trace(Context.typeof(e));
        return e;
      } 
}

\subsection{Ordem de montagem}

A ordem de montagem dos tipos não é especificada e isso se estende a ordem de execução das macros de montagem (ver seção). Ainda que certas regras possam ser determinadas, nós recomendamos efusivamente que não se fie na ordem de execução das macros de montagem. Se a construção de tipos exige múltiplas passadas, isso não deve ser refletir diretamente no código da macro. De forma a evitar multiplas execuções de macros de montagem sobre o mesmo tipo, o estado pode ser armazendado em variáveis estáticas ou adicionados como metadados ao tipo em questão:

import haxe.macro.Context;
import haxe.macro.Expr;

#if !macro
@:autoBuild(MyMacro.build())
#end
interface I1 { }

#if !macro
@:autoBuild(MyMacro.build())
#end
interface I2 { }

class C implements I1 implements I2 { }

class MyMacro {
    macro static public function
    build():Array<Field> {
        var c = Context.getLocalClass().get();
        if (c.meta.has(":processed")) return null;
        c.meta.add(":processed",[],c.pos);
        // process here
        return null;
    }
}

Com ambas interfaces I1 e I2 tendo o metadado :autobuild, a macro de montagem é executada duas vezes para a classe C. Previnimos o processo duplicado adicionando um metadado personalizado :processed a classe, o que pode ser verificado durante a segunda execução da macro.

\subsection{Parâmetros de tipo}

\section{Macros de inicialização}

Macros de inicialização são chamadas da linha de comando usando --macro callExpr(args). Isso registra uma uma retrochamada que o compilador executal depois de criar seu contexto, mas antes de tipificar o que foi passado como argumento para -main. Isso, então, permite a configuração do compilador de algumas maneiras.

Se o argumento para --macro é uma chamada a um simples identificador, aquele identificador é procurado na classe haxe.macro.Compiler que é parte da Biblioteca Padrão do Haxe. A classe vem com diversas macros de incicialização que são detalhadas em sua API (http://api.haxe.org//haxe/macro/Compiler.html)

Como um exemplo, a macro include permite a inclusão de um pacote inteiro para compilação, recursivamente se necessário. O argumento de linha de comando para isso seria --macro include ('some.pack', true).

É claro que também é possível definir macros personalizadas de inicialização para executar diversas tarefas antes da compilação em si. Uma macro como essa seria chamada via --macro some.Class.theMacro(args). Um caso possível, uma vez que todas as macros compartilham o mesmo contexto, uma macro de inicialização poderia atribuir o valor de um campo estático para que outras macros utilizem como configuração.

Parte III - Biblioteca Padrão

\chapter{Biblioteca padrão}

N.do T.: Texto da Introdução ao Haxe e não do Manual

A Biblioteca Padrão do Haxe fornece ferramentas para uso geral sem intenção de ser uma coleção exaustiva de estruturas de dados e algoritmos. Uma distribuição de Haxe vem com um diretório \expr{std} contendo a Biblioteca Padrão do Haxe. Seu conteúdo pode ser categorizado como:

- Uso geral: O diretório std em si contém poucas classes de primeiro nível como Array, Map ou String que podem ser usadas em todos os targets. O subdiretório haxe oferece estruturas de dados adicionais APIs de entrada e saída (input e output, io) e muitas outras ferramentas.

- Sistema: o subdiretório sys contém APIs relacionadas a sistemas de arquivo e bancos de dados. Adicionalmente as classes de topo permitem várias interações com o sistema operacional. Elas também podem ser acessadas quando se compila para um target da categoria sys-category(C++,C#,Java,Neko,PHP).

- Específicas de targets: Cada target do Haxe tem um subdiretório distinto contendo APIs específicas àquele target; Essas só podem ser acessadas quando se compila para o dado target.

API de uso geral:

Nível superior:

Array: Coleção tipada que define diversas operações de acordo com as especificações ECMA

Datas, Ferramentas para datas: Operações relativas a datas e marcação de horário (timestamps)

EReg: Expressões Regulares

Lambda: Operações sobre iteráveis

Map: estrutura de dados de mapeamento chave-para-valor

Math: Funções matemáticas de acordo com as especifiações ECMA

Reflect: reflexão relacionada a campos

Std: Verificação de tipos em tempo de execução, análise sintática de números (parsing), conversão para Int e String

String: operações básicas sobre Strings

StringBuf: Otimizada para montagem de Strings

StringTolls: Varias extensões a Strings

Type: Reflexão relacionada a Type

XML: XML entre plataformas

O pacote haxe:

haxe.Http: Requisições HTTP

haxe.Json: Codificando e decodificando JSON

haxe.Resource: Trabalha com recursos do Haxe

haxe.Serializer: Serializa objetos arbitrários como String

haxe.Template: Um sistema simples de templates (modelos, gabaritos)

haxe.Timer: Execução repetida/adiada; cronômetro

haxe.Unserializer: complemento do haxe.Serializer

haxe.Utf8: Strings UTF8 entre plataformas

haxe.crypto: vários algoritmos de encriptação

haxe.macro: Tipos para trabalhar com macros de Haxe

haxe.remoting: para criar aplicações remotas entre varios tipos de cliente e servidores

haxe.rtti: Informações de tipo em tempo de execução

haxe.unit: Ambiente de testes de unidades básicas

haxe.web: Mapas de URLs para operações

haxe.xml: ferramentas complementares de XML

haxe.zip: suporte ao formato zip

O pacote haxe.ds.package:

haxe.ds.ArraySort: Ordenamento de array multiplataforma estável

haxe.ds.BalancedTree: estrutura de dados de árvore equilibrada

haxe.ds.EnumValueMap: Tipo Map com suporte para chaves de valores de enum

haxe.ds.GenericStack: Estrutura de dados de stack que é otimizada em targets estáticos

haxe.ds.IntMap: Tipo Map com suporte para chaves Int

haxe.ds.ObjectMap: Tipo Map com suporte a chaves object

haxe.ds.StringMap: Tipo Map com suporte a chaves String

haxe.ds.Vector: estruturas de dado de tamanho fixo

O pacote haxe.io 

haxe.io.Bytes: Operações em bytes sobre representações nativas

haxe.io.BytesBuffer: Otimizada para montagem do tipo Bytes (haxe.io.Bytes)

haxe.io.Path: Operações sobre strings de caminhos

API de Sistema:

Disponíve em C++, C#, Java, Neko e PHP.

Sys: Executa comandos nativos, interage com stdin, stdout e stderr; várias outras operações nativas.

sys.FileSystem: Lê e modifica diretórios; obtém informações sobre arquivos e diretórios

sys.db: APIs para trabalhar com bancos de dados MySQL e SQLite

sys.io.File: Lê e escreve conteúdo de arquivos; copia arquivos

sys.io.Process: usa processos nativos

APIs específicas de targets:

- cpp:
 --cpp.Lib: Interações de baixo nível com o target cpp
 --cpp.net: Ferramentas para interagur com redes e servidores em execução
 --cpp.vm: API de threads, debugger, profiler, etc.
 --cpp.zip: API para trabalhar com compressão zip

- cs: API para o target C#

- flash:
 -- flash: Externalizações para a API de Flash
 -- flasg.Lib: Interações básicas com a plataforma Flash
 -- flash.Memory: Externalizações para a API Memory do Flash
 -- flash.Vector: Externalização para Vectors de Flash

- flash8:
 -- flash8: Externalizações para API do Flash 8

- java: API para o target Java

- js:
 --js.Browser: Atalhos para funções comuns de browsers
 --js.Cookie: Assistentes para interagir com cookies HTTP no browser
 --js.JQuery: Classes externalizadas e assistentes para JQuery
 --js.Lib: Atalhos para alert(), eval() e debugger
 --js.html: Externalizações para interagir com o DOM do browser

- neko:
 -- neko.Lib: Interações de baixo nível com a plataforma neko
 -- neko.Web: Funciona com requisições e respostas HTTP
 -- neko.net: Ferramentas para trabalhar com redes e servidores em execução -- neko.vm: API para aplicações multi-threaded
 -- neko.zip: API para trabalar com compressão zip

- php:
 -- php.Lib: Interação de baixo nível com a plataforma PHP
 -- php.Session: Funciona com seções nativas de PHP
 -- php.Web:Funciona com requisições e resposta HTTP
 -- php.db.PDO: driver adicional de PDO para interação com bancos de dados

 


class Main {
    static public function main() { }
}


\section{String}

\definition{Type:String}{Um String é uma sequência de caracteres.}

\section{Estruturas de dados}

\subsection{Array}

\Um Array é uma coleção de elementos. Ele tem um parâmetro de tipo que corresponde aos tipos desses elementos. Arrays podem ser criados de três formas:

1. Usando seu constructor: new Array()

2. Usando a sintaxe de declaração de array (ver seção): [1, 2, 3]

3. Usando o preenchimento de array (ver seção): [for (i in 0...10) if (i % 2 == 0) i]

Arrays vem com uma API para atender a maioria dos casos de uso. Adicionalmente eles permitem acesso a escrita e leitura dos arrays.

class Main {
    static public function main() {
        var a = [1, 2, 3];
        trace(a[1]); // 2
        a[1] = 1;
        trace(a[1]); // 1
    }
}

Uma vez que o acesso a arrays in Haxe é ilimitado, isto é, se garante que le não lance uma mensagem de excessão, isso exige maior discussão:

- Se um acesso de leitura é feito em um índice não existente, um valor dependente do target é retornado.

- Se um acesso de escrita é feiuto com um índice positivo que é além do limite, null (ou o valor padrão (ver seção) de tipos básicos (ver seção) em targets estáticos (ver seção)) é inserido em todas as posições entre o último índice definido e o recém-escrito.

- Se o acesso é feito com um índice negativo, o resultado é inespecífico.

Arrays definem um iterador(ver seção) sobre seus elementos. Essa iteração é tipicamente otimizada pelo compilador para uso com loop while (ver seção) para o índice do array:

class Main {
    static public function main() {
        var scores = [110, 170, 35];
        var sum = 0;
        for (score in scores) {
            sum += score;
        }
        trace(sum); // 315
    }
}

O Haxe gera o seguinte Javascript otimizado:

Main.main = function() {
    var scores = [110,170,35];
    var sum = 0;
    var _g = 0;
    while(_g < scores.length) {
        var score = scores[_g];
        ++_g;
        sum += score;
    }
    console.log(sum);
};

O Haxe não permite arrays com tipos mistos ao menos que o tipo de parâmetro seja forçado como Dynamic(ver seção):

class Main {
    static public function main()
        // Erro de compilação: Arrays de tipo misto só
        // são permitidos se o tipo é forçado  para
        // Array<Dynamic>
        //var myArray = [10, "Bob",false];

        // Array<Dynamic> with mixed types
        var myExplicitArray:Array<Dynamic> =
        [10, "Sally", true];
    }
}

\trivia{Arrays dinâmicos}{Em Haxe 2, declaração de arrays de tipo mistos eram permitidas. Em Haxe 3, arrays só podem ter tipos mistos se forem explicitamente declarados como Array<Dynamic>.

\subsection{Vetor(haxe.ds.Vector)}

Um vetor é uma coleção otimizada de elementos de tamanho fixo. Parecido com Arrays (ver seção), tem um parâmetro de tipo e todos os elementos do vetor devem ser do tipo especificado; ele pode ser iterado com o uso de um loop for (ver seção) e acessado utilizando a sintaxe de array (ver seção). Entretanto, diferente de arrays e listas, o comprimento de um vetor é especificado na sua criação e não pode ser mudado depois.

class Main {
    static function main() {
        var vec = new haxe.ds.Vector(10);
            for (i in 0...vec.length) {
            vec[i] = i;
        }

    trace(vec[0]); // 0
    trace(vec[5]); // 5
    trace(vec[9]); // 9
    }
}

haxe.ds.Vector é implementado como um tipo abstrato sobre a implementação nativa do array para um dado target e pode ser mais rápido para coleções de tamanho fixo, porque a memória para armazenamento de seus elementos é pré-alocada.

\subsection{Lista (haxe.ds.list)}

Uma lista é uma coleção para armazenamento de elementos. Na superfície uma lista é similar a um Array (ver seção). Entretando, a implementação subjacente é muito diferente, isso resulta em diversas diferenças de funcionamento:

1. Uma lista não pode ser indexada com o uso de colchetes, i.e. [0].

2. Uma lista não pode ser inicializada.

3. Não há preenchimento de listas

4. Uma lista pode modificar/adicionar/subtrair elementos livremente enquanto é iterada.

Veja a API List (http://api.haxe.org/List.html para detalhes sobre os métodos de listas. Um simples exemplo para trabalhar com listas:

class ListExample {
    static public function main() {
        var myList = new List<Int>();
        for (ii in 0...5) myList.add(ii);
        trace(myList); //{0, 1, 2, 3, 4}
    }
}

\subsection{Pilha/Stack Genérico (GenericStack)}
Um GenericStack, como Array e List é um container para armazendagem de elementos. Ele tem um parâmetro de tipo (ver seção) e todos os elementos do stack devem ser do tipo especificado. Veja a API GenericStack para detalhes sobre seus métodos. Aqui um pequeno exemplo de um programa para a inicialização e uso de um GenericStack.

import haxe.ds.GenericStack;

class GenericStackExample {
    static public function main() {
        var myStack = new GenericStack<Int>();
        for (ii in 0...5) myStack.add(ii);
        trace(myStack); //{4, 3, 2, 1, 0}
        trace(myStack.pop()); //4
    }
}

\trivia{Lista Rápida}{Em Haxe 2, a classe GenericStack era conhecida com FastList. Uma vez que seu comportamento é bem parecdio com um stack típico, o nome foi mudado para o Haxe 3}

O Generic em GenericStack é literal. É atribuído com o metadado :generic. Dependendo do targe, isso pode levar a melhores desempenhos em targets estáticos. Veja Generic (ver seção).

\subsection{Map}

Um Map é um contêiner composto de pares chave, valor. Um Map também é normalmente tratado por array associativo, dicionário ou tabela de símbolos. O código seguinte dá um breve exemplo do funcionamento de maps:


class Main {
   static public function main() {
       // Maps são inicializados como arrays,
       // mas usam o operador '=>'. Maps podem ter seus
       // tipos de calores chave, definidos explicitamente
       var map1:Map<Int, String> = [1 => "one", 2=>"two"];

       // ou pdem inferir os tipos de seus pares chave valor
       var map2 = ["one"=>1, "two"=>2, "three"=>3];
       $type(map2); // Map<String, Int>

	// Chaves devem ser únicas
	// Erro: Chave duplicada  
        //var map3 = [1=>"dog", 1=>"cat"];

        // Valores de Maps podem ser acessados 
        // usando acessadores de  array
        // accessors "[]"
        var map4 = ["M"=>"Monday", "T"=>"Tuesday"];
        trace(map4["M"]); //Monday
        
        // Maps iteram sobre os seus valores por padrão
        var valueSum;
        for (value in map4) {trace(value);} // Monday \n Tuesday

        // Podem iterar sobre as chaves usando 
        // método keys()
        for (key in map4.keys()) {trace(key);} // M \n T

        // Como arrays un novo Map pode ser
        // criado usando preenchimento
        var map5 = [ for (key in map4.keys())  key => "FRIDAY!!"];
        trace(map5); // {M => FRIDAY!!, T => FRIDAY!!}
    }
}

Veja a API de Map  (http://api.haxe.org/Map.html) para detalhes sobre seus métodos.

Debaixo do capô,um Map é um tipo abstrato (ver seção). Em tempo de compilação ele é convertido de uma diversos tipos especializados dependendo do tipo da chave:

- String: haxe.ds.StringMap

- Int: haxe.ds.IntMap

- EnumValue: haxe.ds.EnumValueMap

{}:haxe.ds.ObjectMap

O tipo Map não existe em tempo de execução e foi substituído por um dos objetos acima. Map defince o acesso como array (ver seção) usando o tipo de sua chave.

\subsection{Option}

Um option é um enum (ver seção) na Biblioteca Padrão do Haxe que é definido assim:

enum Option<T> {
    Some(v:T);
    None;
}

Ele pode ser usado em várias situações, como para comunicar se um método tem ou não um retorno válido e, caso tenha, qual valor retornou:

import haxe.ds.Option;

class Main {
    static public function main () {
        var result = trySomething();
        switch (result) {
            case None:
                trace("Got None");
            case Some(s):
                trace("Got a value: " +s);
        }
    }

    static function
    trySomething():Option<String> {
        if (Math.random() > 0.5) {
            return None;
        } else {
            return Some("Success");
        }
    }
}

\section{Expressões Regulares}

O Haxe tem suporte interno a expressões regulares\footnote{http://pt.wikipedia.org/wiki/Express%C3%A3o_regular}. Elas podem ser usadas para verificar o formato de um string, transformar um string ou extrair dados regulares de um dado texto.

O Haxe tem uma sintaxe especial para a criação de expressões regulares. Nós podemos criar um objeto expressão regular digitando-a entre a combinação de caracteres ~/ e uma barra simples /:

var r = ~/haxe/i;

Alternativamente, podemos criar uma expressão regular com a sintaxe normal:

var r = new EReg("haxe","i");

O primeiro argumento é uma string com um padrão de expressão regular, o segundo é um string com um sinalizador (flag, ver abaixo).

Podemos usar padrões usuais de expressões regulares como:

. (dot) qualquer caractere

* repetir zero ou mais vezes

+ repetir uma ou mais vezes

? opcional zero-ou-um

[A-Z0-9] intervalos de caracteres

[^\r\n\t] caractere fora do intervalo

N do T{
^ negação :^c = não c, ^x-z = diferente de x, y ou z

acho que \r caractere de retorno de carro (carriage return)

\t caractere de tabulação (tab)

\n caractere de nova linha (que depende do OS?) 
}

(...) parentes para localizar grupos de caracteres

^ começo do string (começo de uma linha em modo de localização multilinhas)

$ fim do string (fim da linha no modo de localização multilinhas)

| declaração "OU"


Por exemplo, a expressão regular seguinte localiza endereços de e-mail válidos:

~/[A-Z0-9._\¢-]+@[A-Z0-9.-]+\.[A-Z][A-Z][A-Z]?/i;

Por favor, observe que o i ao final da expressão regular é um sinalizador (flag) que ativa a indiferença entre maiúsculas e minúsculas na localização.

Os sinalizadores possíveis são os seguintes:

i indiferença a maiúsculas e minúsculas

g substituição global ou divisão, veja abaixo

m modo de localização multilinha, ^ e $ representam o começo e o final de uma linha

s o ponto . também localiza novas  linhas (apenas nos targets Neko, C++, PHP e Java)

u usa localização com UTF-8 (apenas targets Neko e C++)

\subsection{Localização}

Provavelmente um dos usos mais comuns para expressões regulares é a verificação de encaixe de um string a um determinado padrão específico. O método match de um objeto expressão regular pode ser usado para fazer isso:

class Main {
    static function main() {
        var r =  ̃/world/;
        var str = "hello world";
        // true : ’world’ foi encontrado no string
        trace(r.match(str));
        // false: 'world' não foi encontrado no string "hello !"
        trace(r.match("hello !"));
    }
}

\subsection{Grupos}

Informações específicas podem ser extraídas de um string onde houve localização com o uso de groups. Se match() retornar true, podemos pegar o grupos usando o método matched(X), onde X é o número do grupo definidio pelo padrão da expressão regular:

class Main {
    static function main() {
       var str = "Nicolas is 26 years old";
       var r =  ̃/([A-Za-z]+) is ([0-9]+) years old/;
       r.match(str);
       trace(r.matched(1)); // "Nicolas"
       trace(r.matched(2)); // "26"
    }  
}

Observe que os números dos grupos começam em 1 e que r.matched(0) sempre retorna todo o substring localizado.

r.matchedPos() retornará a posição desse substring no string original:

class Main {
    static function main() {
       var str = "abcdeeeeefghi";
       var r =  ̃/e+/;
       r.match(str);
       // "eeeee"
       trace(r.matched(0));
       // { pos : 4, len : 5 }
       trace(r.matchedPos());
    }
}

Adicionalmente, r.matchedLeft() e r.matchedRight() podem ser usados para pegar substrings à esquerda e a direita do substring localizado:

class Main {
     static function main() {
         var r =  ̃/b/;
         r.match("abc");
         trace(r.matchedLeft()); // a
         trace(r.matched(0)); // b
         trace(r.matchedRight()); // c
     }
}

\subsection{Replace}

Uma expressão regular também pode ser usada para substituir uma parte do string:

class Main {
    static function main() {
        var str = "aaabcbcbcbz";
        // g : replace all instances
        var r =  ̃/b[ˆc]/g;
        // "aaabcbcbcxx"
        trace(r.replace(str,"xx"));
    }
}

Podemos usar $X para reutilizar um grupo localizado na substituição:

class Main {
    static function main() {
        var str = "{hello} {0} {again}";
        var r = ~ /{([a-z]+)}/g;
        // "*hello* {0} *again*"
        trace(r.replace(str,"*$1*"));
    }
}

\subsection{Split(Partilha)}

Uma expressão regular pode também ser usada para partir um string em diversos substrings:

class Main {
    static function main() {
        var str = "XaaaYababZbbbW";
        var r = ~/[ab]+/g;
        // ["X","Y","Z","W"]
        trace(r.split(str));
    }
}

\subsection{Map}

O método Map de um objeto expressão regular pode ser usado para substituir substrings usando uma função personalizada:

class Main {
    static function main() {
        var r =  ̃/world/;
        var s = "Hello, world!";
        var s2 = r.map (  s, function(r) {return "Haxe";} );
        trace(s2); // Hello, Haxe!
}

Essa função toma um objeto de expressão regular como primeiro argumento de forma que possamos usá-lo para tirar informações adicionais da correspondência sendo feita.

\subsection{Detalhes de Implementação}

Expressões regulares são implementadas:

- em JavaScript, a execução oferece a implementação com o objeto RegExp

- em Neko e C++, a biblioteca PCRE é utilizada

- em Flash, PHP, C# e Java, implementações nativas são usadas

- em Flash 6/8, a implementação não está disponível

\section{Bibllioteca Matemática(Math)}

O Haxe inclui uma biblioteca matemática de ponto flutuante para algumas operações mateméticans comuns. A maioria das funções opera sobre e retorna floats. Entretanto um Int pode ser usado onde um Float é esperado, e o Haxe também converte Int para Float durante a maioria das operações numéricas (verOperadores Numéricos (ver  seção) para maiores detalhes)

Aqui estão alguns exemplos de uso da biblioteca matemática. Ver Math API (http://api.haxe.org/Math.html) para todas as funções disponíveis.

class MathExample {
     static public function main() {
         var x = 1/2;
         var y = 20.2;
         var z = -2;
         
         trace(Math.abs(z)); //2
         trace(Math.sin(x*Math.PI)); //1
         trace(Math.ceil(y)); //21

         // log é o log natural  
         trace(Math.log(Math.exp(5))); //5

        // Output for neko target, may vary
        // depending on platform
        Trace(1/0); //inf
        Trace(-1/0); //-inf
        Trace(Math.sqrt(-1)); //nan
     }
}

\subsection{Números especiais}

A biblioteca matemática tem definições para diversos números especiais:

NaN (Not a Number): retornado quando uma operação matematicamente incorreta é executado, e.g.,Math.sqrt(-1)
POSITIVE_INFINITE: divisão de um número positivo por zero
POSITIVE_NEGATIVE: divisão de um número negativo por zero

\subsection{Erros matemáticos}

Ainda que o neko possa manusear erros matemáticos com fluidez, como a a divisão por zero, isso não é verdade para todos os targets. Dependendo do target, erros matemáticos podem produzir excessões e ultimamente, erros.

\subsection{Matemática com Inteiros}

Se você está compilando para uma plataforma que pode utilizar operações com inteiros, e.g., divisões de inteiros, você deve envelopar isso no Std.int() para melhor desempenho. O compilador do Haxe pode então, otimizar o resultado para operações inteiras. Um exemplo:

var intDivision = Std.int(6.2/4.7);

\subsection{Extensões}

É comum ver Extensões Estáticas (ver seção) usadas com a biblioteca matemática. Este código mostra um exemplo simples:

class MathStaticExtension {
    /* Converts an angle in radians to degrees */
    inline public static function
    toDegrees (radians :Float) :Float
    {  
    return radians * 180/Math.PI;
    }
}

using MathStaticExtension;
class TestMath{
    public static function main(){
    var ang = 1/2*Math.PI;
    trace(ang.toDegrees()); //90
    }
}

\subsection{Lambda}

\subsection{Reflexão}

O Haxe suporta reflexão de tipos e campos em tempo de execução. Cuidado especial deve ser tomado aqui porque a representação em tempo de execução geralmente vária de um target para outro. De forma a usar reflexão corretamente é necessário entender que tipos de operações são suportadas e quais não. Dada a natureza dinâmica da reflexão, isso nem sempre pode ser determinado em tempo de compilação.

A API de reflexão consiste em duas classes:

Reflect: Uma API leve que funciona melhor em estruturas anônimas (ver seção)

Type: Uma API mais robusta para trabalhar com classes e enums (ver seção)

Os métodos disponíveis são detalhados nas APIs Reflect (http://api.haxe.org//Reflect.html) e Type (http://api.haxe.org//Type.html)

Reflexão pode ser uma ferramenta poderosa, mas é importante entender porque ela também pode causar problemas. Como um exemplo, diversas funções esperam um argumento String (ver seção) e tentam resolvê-lo para um tipo ou campo. Isso é vunerável a erros de digitação:

class Main {
    static function main() {
         trace(Type.resolveClass("Mian")); // null
    }
}

Entretanto, mesmo que não existam erros de digitação é fácil esbarrar em comportamentos inesperados:

class Main {
   static function main() {
       // null
       trace(Type.resolveClass("haxe.Template"));
   }
}

O problema aqui é que o compilador nunca chega a ver realmente a tipo jaxe.Template, então não o compila para o resultado. Além disso, mesmo que ele visse o tipo, poderiam aparecer problemas partindo da eliminação de código morto (ver seção) onde tipos e campos que só são utilizados via reflexão sejam eliminados.

Um outro conjunto de problemas deriva do fato que, por concepção, diversas funções de reflexão esperam argumentos do tipo Dynamic, implicando que o compilador não pode verificar se os argumentos passados estão corretos. O exemplo seguinte mostra um engano normal quando se trabalha com callMethod:

class Main {
    static function main() {
        // wrong
        //Reflect.callMethod(Main, "f", []);
        // right
        Reflect.callMethod(Main, Reflect.field(Main, "f"), []);
    }
    static function f() {
        trace(’Called’);
    }
}

A chamada comentada poderia ser aceita pelo compilador porque ela atribui o string "f" como argumento da função func, especificada para ser do tipo Dynamic.

Um bom conselho para trabalhar com reflexão é envelopá-la em algumas poucas funções dentro da aplicação ou API para que sejam chamadas por código com tipagem segura. Um exemplo segue:

typedef MyStructure = {
    name: String,
    score: 12
}

class Main {
     static function main() {
     var data = reflective();
     // Nesse ponto o dado já está convenientemente tipado como
     // MyStructure
}
    static function reflective():MyStructure {
        // Trabalho  com reflexão aqui para obter
        // alguns valores que queremos retornar
        return {
            name: "Reflection",
            score: 0
        }
    }
}

Ainda que o método reflective pudesse trabalhar inteiramente com reflexão (e o tipo Dynamic para tanto), seu tipo de retorno é uma estrutura tipada que as chamadas podem usar de uma maneira segura em relação a tipos. 


\section{Serialização}

Muitos valores de tempo de execução podem ser seriados e deseriados usando as classes haxe.Serializer e haxe.Unserializer. Ambas suportam dois usos:

1. Criação de uma instância e continuas chamadas do método serialize/usserialize para manusear múltiplos valores.

2. Chamada do seu método estático rum para seriar/deseriar um único valor.

O exemplo seguinte mostra  primeiro uso:

import haxe.Serializer;
import haxe.Unserializer;

class Main {
    static function main() {
        var serializer = new Serializer();
        serializer.serialize("foo");
        serializer.serialize(12);
        var s = serializer.toString();
        trace(s); // y3:fooi12

        var unserializer = new Unserializer(s);
        trace(unserializer.unserialize()); // foo
        trace(unserializer.unserialize()); // 12
    }
}
 
O resultado da serialização (aqui armazendado na variável local s) é um String (ver seção) que pode ser jogado para lá e para cá, mesmo remotamente. Seu formato é descrito em Formatos de serialização (ver seção).

Valores suportados:

- null 
- Bool, Int e Float (incluindo infinitos e NaN)
- String
- Date
- haxe.io.Bytes (codificados em base64)
- Array (ver seção) e List (ver seção)
- haxe.ds.StringMap, hase.ds.IntMap e haxe.ds.ObjectMap
- estruturas anônimas (ver seção)
- instâncias de classes haxe (ver seção) (e não instânciad de classes nativas)
- instâncias de enums

Configuração de serialização A serialização pode ser configurada de duas maneiras. Para ambas, uma variável estática pode ser definidad para influenciar todas as instâncias de haxe.Serializer e uma variável membro pode ser definida para influenciar apenas uma instância específica:

USE_CACHE, useCache: Se verdadeira, objetos repetidos são seriado por referência. Isso pode evitar loops infinitos para dados recursivos ao custo de um tempo maior de serialização. Por padrão, esse valor é falso.

USE_ENUM_INDEX, useEnumIndex:Se verdadeira, constructors de enum são seriados por seu índice em vez de seu nome. Isso pode tornar a serialização de strings mais curta, mas se quebra se constructors de enum são inseridos nos tipos antes da deserialização. Por padrão, esse valor é falso.

Comportamento de deserialização Se o resultado de serialização é armazenado e depois usado para deserialização, cuidado deve ser tomado para manter a compatibilidade quando se trabalha com instâncias de enums e classes. É, então, importante entender exatamente como a deserialização é implementada.

- O tipo tem que estar disponível em tempo de execução aonde a deserialização é feita. Se a eliminação de código morto (ver seção) está ativa, um tiṕ que só é usado através de serialização pode ser removido.

- Cada Unserializer tem uma variável membro resolver que é usada para resolver classes e enums por nome. Na criação do Unserializer, isso é usado para definir Unserializer.DEFAULT_RESOLVER. Tanto ela quanto o membro da instância pode ser definidos para  definir um "resolver" personalizado.

- Classes são resolvidas por nome, usando resolver.resolveClass(name). A instância é, então, criada usando Type.createEmptyInstance, o que implica que o constructor da classe não é chamado. Finalmente, os campos da instância são definidos de acorodo com o valor serializado

- Enums são resolvidos por nome usando resolver.resolveEnum(name). A instância do enum é, então, criada usando Type.createEnum, usando os valores de argumento serializados, se disponíveis. Se os argumentos do constructor foram mudados desde a serialização, o resultado é não especificado.

(De)Serialização personalizada Se uma classe deifini o método membro hxSerialize, esse método é chamado pelo serializador, permitindo uma serialização personalizada da classe. Da mesma forma, se uma classe define o método membro hxUnserialize, ele é chamado pelo deserializador:

import haxe.Serializer;
import haxe.Unserializer;

class Main {
    var x:Int;
    var y:Int;

    static function main() {
        var s = Serializer.run(new Main(1, 2));
        var c:Main = Unserializer.run(s);
        trace(c.x); // 1
        trace(c.y); // -1
    }
    function new(x, y) {
        this.x = x;
        this.y = y;
    }
    @:keep
    function hxSerialize(s:Serializer) {
        s.serialize(x);
        }
    @:keep
    function hxUnserialize(u:Unserializer) {
        x = u.unserialize();
        y = -1;
    }
}

Nesse exemplo decidimos que vamos ignorar o valor membro da variável y e não serializá-lo. Ao invés disso o padronizamos para -1 em hxUnserializa. Ambos os métodos são anotados com o metadado :keep para previnir que a eliminação de código morto (ver seção) os removam, uma vez que elas nunca são propriamente referenciadas no código.

\subsection{Formato de Serialização}

Cada valor suportado é traduzido para um caracter de prefixo distinto, seguido pelos dados necessários:

null: n

Int: z para zero ou i seguido do próprio integer(e.g.i456)

Float: NaN: k
       infinito negativo: m
       infinito positivo: p
       float normal: d seguido da exibição do float (e.g d1.45e-8)

Bool: t para verdadeiro (true) e f para falso (false)

String: y seguido do comprimento do string codificado para url, seguido de dois pontos e o string codificado em url em si (e.g.:y10:hi%20there para "hi there")

String(cacheado):R seguido pelo ID do cache (e.g. R456). O cacheamento de string está sempre habilitado.

Pares nome-valor: um string serializado representando o nome, seguido pelo valor.

estrutura: o seguido de uma lista de pares nome-valor, seguidos por g (e.g. oy1:xi2y1:kng para {x:2, k:null})

List: l seguido da lista dos itens seriados, seguido por h (e.g lnnh para uma lista de dois valores nulos)

Array: a seguido por uma lista dos itens seriados, seguido por h. Para múltiplos valores null consecutivos, u segudio pelo número de valores nulos é utilizado (e.g. ai1i2u4i7ni9h para [1,2,null,null,null,null,9])

Data: v seguido pela propria data (e.g. d2010-01-01 12:45:10)

haxe.ds.StringMap: b seguido pelos pares nome-valor, seguido por ha (e.g by1:xi2y1:knh para {"x" => 2, "k" => null})

haxe.ds.IntMap: q seguido pelos pares chave-valor, seguido por ha. Cada chave é representada como :<int> (e.g. q:4n:5i45:6i7h para {4 => null, 5 => 45, 6 =>7})

haxe.ds.ObjectMap: M seguido por pares valores seriados representado a chave e o valor, seguidos por h

haxe.ds.Bytes: s seguido pela extensão dos bytes codificados em base64, então: e a representação de bytes usando os códigos A-Za-z0-9% (e.g. s3:AAA para 2 bytes igual a 0, s10:SGBsb8gI! para i haxe.io.Bytes.ofString("Hello !") )

exception: x seguido do valor da exceção

instância de classe: c seguido do nome seriado da classe, seguido do pares nome-valor dos campos, seguido de g (e.g. cy5:Pointy1:xzy1:yzg para Point(0,0) qye tenha dois campos integer x e y)

instância de enum (por nome): w seguido do nome do enum seriado, seguido pelo nome seriado do constructor, seguido pelo número de argumentos, seguido pelo valor dos argumentos (e.g. wy3:Fooy1:A0 praa Foo.A (sem argumentos),  wy3:Fooy1:B2i4n para Foo.B(4,null) )

instância de enum (por índice) j seguido do nome seriado do enum, seguido por :, seguido do índice do constructor, seguido pelo número de argumentos, seguido pelo valor (e.g. (como no original, precisa corrigir) wy3:Foo0:0 para Foo.A (sem argumentos), wy3:Foo1:2i4n para Foo.B(4,null) )

personalizado(custom): C seguido pelo nome de classe, seguido pelo dado seriado, segudio por g.

referências ao cache: r seguido pelo índice do cache;

\section {Json}

O Haxe oferece suporte interno para a (de)serialização de dados JSON\footnote{http://pt.wikipedia/wiki/JSON} via classe haxe.Json

\subsection Decomposição sintática de JSON

Use o método estático haxe.Json.parse para decompor sintaticamente dados JSON e obter um valor deles:

class Main {
    static function main() {
        var s = ’{"rating": 5}’;
        var o = haxe.Json.parse(s);
        trace(o); // { rating: 5 }
    }
}

Observe que o tipo de objeto retornado por haxe.Json.parse é Dynamic, então, se a estrutura de nosso dado é bem conhecida, podemos querer especificar um tipo usando estruturas anônimas. Dessa maneira, podemos oferecer verificações em tempo de compilação para acessar nosso dado e comumente otimizar a geração de código, porque o compilador conhece os tipos em uma estrutura:

typedef MyData = {
    var name:String;
    var tags:Array<String>;
}

class Main {
    static function main() {
        var s = ’{
            "name": "Haxe",
            "tags": ["awesome"]
            }’;
        var o:MyData = haxe.Json.parse(s);
        trace(o.name); // Haxe (a string)

        // awesome (a string in an array)
        trace(o.tags[0]);
    }
} 

\subsection{Codificando JSON}

Use o método estático haxe.Json.stringify para codificar um valor de Haxe em um string JSON:

class Main {
    static function main() {
        var o = {rating: 5};
        var s = haxe.Json.stringify(o);
        trace(s); // {"rating":5}
    }
}


\subsection{Detalhes de implementação}

A API haxe.Json usa automaticamente a implementação nativa dos targets onde está disponível, i.e., Javascript, Flash e PHP e fornece sua própria implementação para outros targets.

O uso da própria implementação do Haxe pode ser forçado com o argumento de compilação -D haxeJSON. Isso também fornece a serialização de enums (ver seção) por seus índices, maps (ver seção) com chaves string e instâncias de classes.

Browsers mais velhos (Internet Explorer 7, por exemplo) podem não ter implementação nativa de JSON. No caso de ser necessário suportá-los, nos podemos incluir uma das implementações de JSON na página HTML. Alternativamente um argumento de compilação -D old_browser pode ser usado, ele  fará haxe.Json tentar usar o JSON nativo, mas puxar sua própria implementação no caso de ela não disponível.

\subsection{Xml}

\subsection{Input/Output}

\subsection{Sys/sys}

Parte IV - Miscelânea

\chapter{HaxeLib}

Haxelib é o gerenciado de bibliotecas que vem com qualquer distribuição do Haxe. Conectado a um repositório central, ele permite submeter e retirar bibliotecas e tem múltiplas funcionalidades além dessa. Bibliotecas disponíveis podem ser encontradas em http://lib.haxe.org .

Uma biblioteca de Haxe é uma coleção de arquivos .hx. Isso é, bibliotecas são distribuídas pelo código fonte por padrão, tornando fácil inspecionar e modificar seu comportamento. Cada biblioteca é identificada por um nome único, que é utilizado quando se informa o compilador do Haxe quais bibliotecas usar em uma dada compilação.

\subsection{Usando a bilblioteca do Haxe com o compilador do Haxe}

Qualquer biblioteca instalada do Haxe pode ser disponibilizada para o compilador através do argumento -lib<nome-da-biblioteca>. Isso é muito similar ao argumento -cp<path>, mas espera um nome de biblioteca ao invés de um caminho de diretório. Esses comandos são explicados detalhadamente em Uso do Compilador (ver capítulo).

Para nosso uso exemplificativo, escolhemos uma biblioteca muito simples de Haxe, chamada "random". Ela oferece um conjunto de métodos estáticos convenientes para conseguir diversos efeitos aleatórios (randômicos), como escolher um elemento de um array.

A compilação disso sem qualquer argumento -lib gera uma mensagem de erro Unknow identifier : Random ao longo das linhas. Isso mostra que as bibliotecas instaladas não estão disponíveis para o compilador por padrão a não ser que sejam explicitamente adicionadas. Uma linha de comando que funcione para o programa acima é haxe -lib random -main Main --interp .

Se o compilador enviar um erro Error: Library random is not installed: run 'haxelib install random' a biblioteca tem que ser instalada via comando haxelib primeiro. Como a mensagem de erro sugere, isso é conseguido através do comando haxelib install random. Aprenderemos mais sobre o comando haxelib em Usando o Haxelib (ver seção).

\subsection{haxelib.json}

Cada biblioteca do Haxe exige um arquivo haxelib.json, onde os seguintes atributos são definidos:

name: O nome da biblioteca. Deve conter pelo menos três caracteres entre os seguintes: A-Za-z0-9. Em particukar, espaços não são permitidos.

url: A url da biblioteca, i.e., onde mais informação pode ser localizada;

license: A licença sob a qual a biblioteca é publicada. Pode ser GPL, LGPL, BSD, Public (para domínio público) ou MIT.

tags: um array de strings com rótulos que são usados para o website do repositório ordenar as bibliotecas.

descrição: A descrição do que á biblioteca está fazendo.

versão: Um string de versão da biblioteca. Isso é detalhado em Versionamento (ver seção).

releasenote: Observações da publicação da versão em questão.

contributors: Um array de nomes de usuários que identifique os contribuídores para a biblioteca.

dependencies: Um objeto descrevendo as dependências da biblioteca. Isso é detalhado na seção Dependências (ver seção) 

A JSON seguinte é um simples exemplo de um haxelib.json:

{
    "name": "useless_lib",
    "url" :
        "https://github.com/jasononeil/useless/",
    "license": "MIT",
    "tags": ["cross", "useless"],
    "description":
        "This library is useless in the same way on
         every platform",
    "version": "1.0.0",
    "releasenote":
         "Initial release, everything is working
          correctly",
    "contributors": ["Juraj","Jason","Nicolas"],
    "dependencies": {
        "tink_macros": "",
         "nme": "3.5.5"
     }
}

\subsection{Versionamento}

A Haxelib usa uma versão simplificada do SemVer (http://semver.org). O formato básico é este:

major.minor.patch

As regras básicas são:

Versões major são incrementadas quando se quebra compatibilidade retroativa - de forma que códigos antigos não funcionarão com a nova versão da biblioteca.

Versões minor são incrementadas quando novas funcionalidades são adicionadas

versões patch são para pequenas correções que não alteram a API pública. Quando uma versão menor é incrementada, o número patch é retornado para 0. Quando uma versão major é incrementada, tanto o número minor quanto o número patch são retornados para zero.

Exemplos:

0.0.1: Uma primeira divulgação. Qualquer coisa com um 0 para versão major pe sujeito a mudanças na próxima divulgação - nenhuma promessa de estabilidade de API!

0.1.0: Inclui uma nova funcionalidade! Incrementa a versão minor, zera a versão patch

0.1.1: Percebeu-se que a nova funcionalidade estava quebrada. Consertada agora, se incrementa o número patch

1.0.0: Nova versão major, assim se incrementa o número major e se zera os números minor e patch. Você promete aos seus usuários não quebrar essa API até que você pule para 2.0.0

1.0.1: Um conserto menor

1.1.0: Uma nova funcionalidade

1.2.0: Outra nova funcionalidade

2.0.0: Uma nova versão, que pode quebrar a compatibilidade com 1.0. Usuários devem ser cuidadosos ao se atualizarem.

Se essa divulgação é um pré-visão (Alfa, Beta ou Candidato a lançamento), você pode incluir iss, com um número opcional de divulgação:

major.minor.patch-(alpha/beta/rc).release

Exemplos:

1.0.0-alpha: O alfa de 1.0.0 - use com cuidado, as coisas estão mudando

1.0.0-alpha.2: O segundo alfa

1.0.0-beta: Beta - as coisas estão se firmando, mas ainda sujeitas a alterações.

1.0.0-rc.1: O primeiro candidato a lançamento (rc=release candidate) para 1.0.0 - não se colocarão novas funcionalidades agora

1.0.0-rc.2 O segundo candidato a lançamento para 1.0.0

1.0.0: o lançamento final!

\subsection{Dependências}

A partir do Haxe 3.1.0, a haxelib suporta unicamente o casamento de versões exatas como dependências. Dependências são definidas como parte do haxelib.json (ver seção), com o nome da biblioteca servindo como chave e a versão esperado (se requerido) como um valor no formato descrito em Versionamento (ver seção). Já vimos um exemplo disso quando apresentamos o haxelib.json:

"dependencies": {
    "tink_macros": "",
    "nme": "3.5.5"
}

Isso adiciona duas dependências para a dada biblioteca Haxe:

1. A biblioteca "tink.macros" pode ser usada em qualquer versão. Haxelib tentará, entãom sempre usar a última versão.

2. A bibiblioteca "nme" é necessária na versão "3.5.5". A Haxelib fará certo que essa exata versão seja usada, evitando potenciais mudanças drásticas com versões futuras.

\section{extraParams.hxml}

Se você somar um arquivo chamado extraParams.hxml a raiz da sua biblioteca (no mesmo nível que haxelib.json) esses parâmetros serão automaticamente somados aos parâmetros de compilação quando alguém usar sua biblioteca com -lib.

\section{Usando a Haxelib}

Se o comando haxelib é executado sem quaisquer argumentos, ele imprime uma lista exaustiva dos argumentos disponíveis.

\chapter{Detalhes de Targets}

\section{Javascript}

\subsection{Carregando classes externas usando a função "require"

Desde Haxe 3.2.0

Plataformas modernas de Javascript, como Node.js fornecem uma maneira de carregar objetos de módulos externos usando a função require. O Haxe suporta a geração automática de declarações "require" para classes externas.

Essa funcionalidade pode ser habilitada pela especificação do metadado @:jsRequire especificando o nome do módulo para carregar:

@:jsRequire("fs")
extern class FS {
    static function readFileSync(path:String,encoding:String):String;
}

Caso nossa classe extern represente um objeto dentro de um módulo, um segundo argumento a @:jsRequire especifica um objeto para leitura de um módulo:

@:jsRequire("http", "Server")
extern class HTTPServer {
    function new();
}

O segundo argumento é um caminho por ponto, para que possamos carregar subobjetos em qualquer hierarquia.

Se precisamos carregar objetos personalizados de Javascript em tempo de execução, uma função js.Lib.require pode ser usado. Ela toma um String como seu único argumento e retorna um Dynamic, então é aconselhado que seja atribuída a uma variável estritamente tipada.






